{
	"version": 3,
	"file": "D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/development/automated_tests/re/__javascript__/basictests.mod.js",
	"sources": [
		"D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/development/automated_tests/re/basictests.py"
	],
	"sourcesContent": [
		"\nfrom org.transcrypt.stubs.browser import __pragma__, __symbols__\nimport re\n__pragma__(\"skip\")\nre.J = (1<<19)\nre.JSSTRICT = re.J\n\ndef convertMappingDict(mdict):\n    \"\"\" This method converts a mapping proxy object to\n    a dict object. mapping proxies create read-only dicts\n    but we don't have that concept in transcrypt yet.\n    \"\"\"\n    ret = {}\n    for k in mdict.keys():\n        ret[k] = mdict[k]\n    return(ret)\n\n__pragma__(\"noskip\")\n\ntestStr1 = \"There,is,No,Time\"\ntestStr2 = \"som[23] In[23423] the[34].asd[934].234.\"\ntestStr3 = \"s(43) d(03) asdfasd dsfsd(3) sd\"\ntestStr4 = \"Were an apple like an orange then apple orange no appleorange\"\n\ndef checkMatchProperties(test, flags = 0):\n    \"\"\" This test checks that properties on the match\n    are reported correctly, and that they are read-only\n    \"\"\"\n    result = re.search(\",\", testStr1, flags)\n    if ( result is not None ):\n        test.check( result.pos )\n        test.check( result.endpos )\n        test.check( result.group() )\n        test.check( result.group(0) )\n        test.check( result.string )\n\n        # Check readonly props of match\n        def assignPos():\n            result.pos = 1\n        test.check(test.expectException(assignPos))\n        def assignEndPos():\n            result.endpos = 1\n        test.check(test.expectException(assignEndPos))\n        def assignRe():\n            result.re = \"asdfasdf\"\n        test.check(test.expectException(assignRe))\n        def assignStr():\n            result.string = \"asdf\"\n        test.check(test.expectException(assignStr))\n        def assignLastGroup():\n            result.lastgroup = \"asdfasdf\"\n        test.check(test.expectException(assignLastGroup))\n        def assignLastIndex():\n            result.lastindex = 33\n        test.check(test.expectException(assignLastIndex))\n    else:\n        test.checkPad(\"NULL\", 11)\n\n\ndef checkRegexProperties(test, flags = 0):\n    \"\"\" This test checks that the appropriate properties\n    exist on the Regex object and that these properties\n    are read-only.\n    \"\"\"\n    r = re.compile(\",\", flags)\n    if ( r is not None ):\n        test.check( r.groups )\n        test.check( r.pattern )\n        test.check( r.flags )\n        d = r.groupindex\n        __pragma__('skip')\n        d = convertMappingDict(d)\n        __pragma__('noskip')\n        test.check( d )\n        # Check Read-only props on regex object\n        def assignPattern():\n            r.pattern = \"asdfasdf\"\n        test.check(\n            test.expectException(assignPattern)\n        )\n        def assignFlags():\n            r.flags = \"wer\"\n        test.check(\n            test.expectException(assignFlags)\n        )\n        def assignGroups():\n            r.groups = 1\n        test.check(\n            test.expectException(assignGroups)\n        )\n        def assignGroupIndex():\n            r.groupindex = 34\n        test.check(\n            test.expectException(assignGroupIndex)\n        )\n    else:\n        test.checkPad(\"NULL\", 8)\n\ndef checkFlagsExist(test):\n    test.check(re.T)\n    test.check(re.I)\n    test.check(re.IGNORECASE)\n    test.check(re.M)\n    test.check(re.MULTILINE)\n    test.check(re.S)\n    test.check(re.DOTALL)\n    test.check(re.U)\n    test.check(re.UNICODE)\n    test.check(re.X)\n    test.check(re.VERBOSE)\n    test.check(re.A)\n    test.check(re.ASCII)\n\ndef escapeTests(test):\n    test.check(re.escape(\"buf[34]\"))\n    test.check(re.escape(\"C:\\\\asdf\\\\wewer\\\\\"))\n    test.check(re.escape(\"func(int a) { return(3)};\"))\n\ndef checkIgnoreCase(test, flags = 0):\n    test.check( re.search(\"as\", testStr3, flags|re.I).pos )\n    test.check( re.search(\"as\", testStr3, flags|re.I).endpos )\n    test.check( re.search(\"as\", testStr3, flags|re.I).group() )\n    test.check( re.search(\"as\", testStr3, flags|re.I).group(0) )\n    test.check( re.search(\"AS\", testStr3, flags|re.I).pos )\n    test.check( re.search(\"AS\", testStr3, flags|re.I).endpos )\n    test.check( re.search(\"AS\", testStr3, flags|re.I).group() )\n    test.check( re.search(\"AS\", testStr3, flags|re.I).group(0) )\n\ndef checkSearchWithGroups(test, flags = 0):\n    r = \"\\\\[([\\\\d]+)\\\\]\"\n    test.check( re.compile(r, flags).groups )\n    test.check( re.search(r, testStr2, flags).pos)\n    test.check( re.search(r, testStr2, flags).endpos)\n    test.check( re.search(r, testStr2, flags).groups())\n    test.check( re.search(r, testStr2, flags).group())\n    test.checkEval(lambda: re.search(r, testStr2, flags).group(0))\n    test.checkEval(lambda: re.search(r, testStr2, flags).group(1))\n    test.check( re.search(r, testStr2, flags).start())\n    test.checkEval(lambda: re.search(r, testStr2, flags).start(0))\n    test.checkEval(lambda: re.search(r, testStr2, flags).start(1))\n\n    test.check( re.search(r, testStr2, flags).end())\n    test.checkEval(lambda: re.search(r, testStr2, flags).end(0))\n    test.checkEval(lambda: re.search(r, testStr2, flags).end(1))\n\n    test.check( re.search(r, testStr2, flags).span())\n    test.checkEval(lambda: re.search(r, testStr2, flags).span(0))\n    test.checkEval(lambda: re.search(r, testStr2, flags).span(1))\n\n    test.check( re.search(r, testStr2, flags).lastgroup)\n    test.check( re.search(r, testStr2, flags).lastindex)\n\n    for i in range(2,50):\n        test.check(\n            test.expectException(lambda: re.search(',', testStr1, flags).group(i))\n        )\n\ndef checkMatchOps(test, flags = 0):\n    test.check( re.match(\"asdf\", \"asdf\", flags).pos )\n    test.check( re.match(r\"asdf\", \"asdf\", flags).endpos )\n    test.check( re.match(\"asdf\", \"asdf\", flags).groups() )\n    test.check( re.match(\"a\", \"asdf\", flags).pos )\n    test.check( re.match(\"a\", \"asdf\", flags).endpos )\n    test.check( re.match(\"a\", \"asdf\", flags).groups() )\n    test.check( (re.match(\"s\", \"asdf\", flags) is None) )\n    test.check( (re.match(r\"^s\", \"asdf\", flags) is None) )\n    test.check( (re.compile(\"^s\", flags).match(\"asdf\", 1) is None) )\n\ndef checkMatchWithNamedGroups(test, flags = 0):\n    \"\"\"\n    \"\"\"\n    # Matches with named groups\n    r = None\n    try:\n        r = re.compile(r\"(?P<prefix>[a-zA-Z]+)://(?P<suffix>[^/]*)\", flags)\n    except Exception as exc:\n        test.checkPad(None, 15)\n\n    if ( r is not None ):\n        test.check(r.groups)\n        test.check(r.pattern)\n        d = r.groupindex\n        __pragma__('skip')\n        d = convertMappingDict(d)\n        __pragma__('noskip')\n        test.check( d )\n\n        m = r.match(\"http://asdf\")\n        test.check( m.groups() )\n        test.check( m.group() )\n        test.check( m.group(0) )\n        test.check( m.group(1) )\n        test.check( m.group(\"prefix\") )\n        test.check( m.group(\"suffix\") )\n\n        m = r.match(\"ftp://192.168.1.1\")\n        test.check( m.group() )\n        test.check( m.group(0) )\n        test.check( m.group(1) )\n        test.check( m.group(\"prefix\") )\n        test.check( m.group(\"suffix\") )\n        m = r.match(\"555-5555\")\n        test.check(m)\n\n    try:\n        r = re.compile(r\"(?P<country>\\d{1,3})-(?P<areacode>\\d{3})-(?P<number>\\d{3}-\\d{4})\", flags)\n    except:\n        test.checkPad(None, 13)\n\n    if ( r is not None ):\n        test.check(r.groups)\n        test.check(r.pattern)\n        d = r.groupindex\n        __pragma__('skip')\n        d = convertMappingDict(d)\n        __pragma__('noskip')\n        test.check( d )\n\n        m = r.match(\"1-234-567-9012\")\n        test.check(m.groups())\n        test.check(m.group())\n        test.check(m.group(0))\n        test.check(m.group(1))\n        test.check(m.group(2))\n        test.check(m.group(3))\n\n        test.check( m.group(\"country\") )\n        test.check( m.group(\"areacode\") )\n        test.check( m.group(\"number\") )\n\n        m = r.match(\"adfs;\")\n        test.check(m)\n\ndef checkMatchWithGroups(test, flags = 0):\n    rgx = re.compile(r'(\\w)(\\w)(\\w)?', flags)\n    test.check(rgx.pattern)\n    test.check(rgx.groups)\n    m = rgx.match('abc')\n    if m:\n        test.check(m.group(0))\n        test.check(m.group(1))\n        test.check(m.group(1, 2))\n        test.check(m.group(2, 1))\n    else:\n        test.checkPad(None, 4)\n\n    # groups() with default value\n\n    m = rgx.match('ab')\n    if m:\n        test.check(m.groups(0))\n    else:\n        test.checkPad(None, 1)\n\n    # Match with group that is non-captured\n    rgx = re.compile(r'(?:[\\w\\s]+)\\[(\\d+)\\]', flags)\n    test.check(rgx.pattern)\n    test.check(rgx.groups)\n\n    m = rgx.match(\"asdf[23]\")\n    if m:\n        test.check( m.groups() )\n        test.check( m.group(0) )\n        test.check( m.group(1) )\n        test.check( test.expectException( lambda: m.group(2) ) )\n    else:\n        test.checkPad(None, 4)\n\n\ndef checkCommentGroup(test, flags = 0):\n    \"\"\" Comment Groups are only supported in Python so will\n    likely fail in javascript only mode\n    \"\"\"\n    r = None\n    try:\n        r = re.compile(r'a(?#foobar)b', flags)\n    except:\n        test.checkPad(None,4)\n\n    if ( r is not None ):\n        test.check(r.groups)\n        test.check(r.pattern)\n        test.check(r.search(\"ab\").group())\n        test.check(r.search(\"er\"))\n\n    try:\n        r = re.compile(r'([\\d]+)(?#blarg)\\[\\]', flags)\n    except:\n        test.checkPad(None, 4)\n        return\n\n    test.check( r.groups )\n    test.check( r.pattern )\n    test.check( r.search(\"1234[]\").group())\n    test.check( r.search(\"asdf[]\"))\n\n\ndef checkFullMatchOps(test, flags = 0):\n    test.check( (re.fullmatch(\"asdf\", \"asdf\", flags).pos))\n    test.check( (re.fullmatch(\"asdf\", \"asdf\", flags).endpos))\n    test.check( (re.fullmatch(\"as\", \"asdf\", flags) is None))\n    test.check( (re.fullmatch(\"q\", \"asdf\", flags) is None))\n    test.check( (re.compile(\"o[gh]\", flags).fullmatch(\"dog\") is None))\n    test.check( (re.compile(\"o[gh]\", flags).fullmatch(\"ogre\") is None))\n\n    m = re.compile(\"o[gh]\", flags).fullmatch(\"doggie\",1,3)\n    if m:\n        test.check(m.pos)\n        test.check(m.endpos)\n    else:\n        test.checkPad(None,2)\n\ndef checkFindAllOps(test, flags = 0):\n    test.check(re.findall(\",\", testStr1, flags)) # No Caps\n    test.check(re.findall(\"\\\\[([\\\\d]+)\\\\]\", testStr2, flags)) # 1 Cap\n    r = \"([^\\d\\s]+\\\\(([\\d]+)\\\\))\"\n    test.check(re.compile(r, flags).groups)\n    test.check(re.findall(r, testStr3, flags)) # 2 Caps\n\ndef checkSplitOps(test, flags = 0):\n    test.check(re.split(\",\", testStr1, 0, flags))\n\n    test.check(re.split(\"(apple|orange)\",testStr4, 0, flags))\n    test.check(re.split(\"\\\\[([\\\\d]+)\\\\]\", testStr2, 0, flags))\n    r = re.compile(\",\", flags)\n    test.check(r.split(testStr1, 0))\n    test.check(r.split(testStr1, 1))\n    test.check(r.split(testStr1, 2))\n    test.check(r.split(testStr1, 3))\n    test.check(r.split(testStr1, 4))\n\n    r = re.compile(\"\\\\[([\\\\d]+)\\\\]\", flags)\n    test.check(r.split(testStr2,0))\n    test.check(r.split(testStr2,1))\n    test.check(r.split(testStr2,2))\n    test.check(r.split(testStr2,3))\n    test.check(r.split(testStr2,4))\n\ndef checkSubOps(test, flags = 0):\n    def dashrepl(matchobj):\n        if matchobj.group(0) == '-':\n            return ' '\n        else:\n            return '-'\n    test.check(re.sub('-{1,2}', dashrepl, 'pro----gram-files',0, flags))\n    test.check(re.sub('-{1,2}', '4', 'pro----gram-files',0, flags))\n    test.check(re.subn('-{1,2}', dashrepl, 'pro----gram-files',0,flags))\n    test.check(re.subn('-{1,2}', '4', 'pro----gram-files',0,flags))\n\ndef checkSyntaxErrors(test, flags = 0):\n    test.check(test.expectException( lambda: re.compile(r')', flags)))\n    test.check(test.expectException( lambda: re.compile(\"a\\\\\", flags)))\n    test.check(test.expectException( lambda: re.compile(r'a[b', flags)))\n    test.check(test.expectException( lambda: re.compile(r'(abc', flags)))\n    test.check(test.expectException( lambda: re.compile(r')(', flags)))\n    test.check(test.expectException( lambda: re.compile(r'))', flags)))\n    test.check(test.expectException( lambda: re.compile(r'a[b-a]', flags)))\n    test.check(test.expectException( lambda: re.compile(r'*a', flags)))\n\ndef checkFindIter(test, flags = 0):\n    \"\"\" Test the finditer method\n    \"\"\"\n    __pragma__ ('ifdef', '__esv5__')\n    if ( '__esv5__' in __symbols__ ):\n        test.check(\"Skip finditer tests in esv5\")\n        return\n    __pragma__('else')\n    p = \"\\\\[([\\\\d]+)\\\\]\"\n    r = re.compile(p, flags)\n    test.check( r.groups )\n\n    iret = r.finditer(testStr2)\n    for m in iret:\n        test.check(m.pos)\n        test.check(m.endpos)\n        test.check(m.string)\n        test.check(m.lastindex)\n        test.check(m.groups())\n        test.check(m.group(0))\n        test.check(m.group(1))\n        test.check(test.expectException( lambda: m.group(2) ))\n        test.check(test.expectException( lambda: m.group(2342)))\n        test.check(test.expectException( lambda: m.group(\"asdf\")))\n        test.check(m.start(0))\n        test.check(m.start(1))\n        test.check(test.expectException( lambda: m.start(\"asdf\")))\n        test.check(m.end(0))\n        test.check(m.end(1))\n        test.check(test.expectException( lambda: m.end(\"asdf\")))\n    __pragma__('endif')\n\ndef checkWithFlags(test, flags = 0):\n    \"\"\" This checks the regex with flags called out in the\n    string, for example (?i) for ignore case.\n    This is a python only feature.\n    \"\"\"\n    try:\n        r = re.compile(r'(?i)aba', flags)\n    except:\n        test.checkPad(None, 5)\n        return\n\n    test.check(r.groups)\n    test.check(r.pattern)\n\n    m = r.search(\"aBA\")\n    test.check(m.group() )\n    test.check(m.groups())\n\n    m = r.match(\"aAa\")\n    test.check(m)\n\n    m = r.match(\"ABA\")\n    test.check(m.group())\n\n    m = r.match(\"abA\")\n    test.check(m.group())\n\n\ndef checkConditionalGroups(test, flags = 0):\n    \"\"\" Check conditional groups - this is a python only\n    feature - will likely faily in the js strict mode\n    \"\"\"\n    rgx = None\n    try:\n        rgx = re.compile(r'(a)?(b)?(?(1)a|c)(?(2)b)', flags)\n    except:\n        test.checkPad(None, 12)\n\n    if ( rgx is not None ):\n#        test.check(rgx.groups)                                             # !!! @JdeH temporarily disabled this\n        test.check(rgx.pattern)\n        test.checkEval(lambda: rgx.match('abab').group())\n        test.checkEval(lambda: rgx.match('aa').group())\n        test.checkEval(lambda: rgx.match('bcb').group())\n        test.checkEval(lambda: rgx.match('c').group())\n        test.checkEval(lambda: rgx.match('abcb'))\n        # PyRegex needs to use n_splits from `translate` for this to work\n        # test.checkEval(lambda: rgx.match('c').groups())                   # !!! @JdeH temporarily disabled this\n        # test.checkEval(lambda: rgx.split(\"ababbababcdjsabbabdbab\"))       # !!! @JdeH temporarily disabled this\n        test.checkEval(lambda: rgx.sub(\"jumbo\", \"ababsdf rexababwer\"))\n        test.checkEval(lambda: rgx.sub(\"shrimp\", \"shipbcb shootc aardvark\"))\n        # test.checkEval(lambda: rgx.findall(\"ababxaaxcebbcxababeded\"))     # !!! @JdeH temporarily disabled this\n\n    try:\n        rgx = re.compile(r'(a)?(b)?(?(1)a|c)(?(2)b|d)', flags)\n    except:\n        test.checkPad(None, 6)\n        return\n\n    # test.check(rgx.groups)                                                # !!! @JdeH temporarily disabled this\n    test.check(rgx.pattern)\n    test.checkEval(lambda: rgx.match('abab').group())\n    test.checkEval(lambda: rgx.match('aad').group())\n    test.checkEval(lambda: rgx.match('bcb').group())\n    test.checkEval(lambda: rgx.match('bcb').group())\n"
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAucA;AArcA;AAiBA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAEA;AAAA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAKA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}