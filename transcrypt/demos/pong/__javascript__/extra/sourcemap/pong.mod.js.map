{
	"version": 3,
	"file": "/mnt/D/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/demos/pong/__javascript__/pong.mod.js",
	"sources": [
		"/mnt/D/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/demos/pong/pong.py"
	],
	"sourcesContent": [
		"__pragma__ ('skip')\ndocument = window = Math = Date = 0 # Prevent complaints by optional static checker\n__pragma__ ('noskip')\n\n__pragma__ ('noalias', 'clear')\n\nfrom com.fabricjs import fabric\n\northoWidth = 1000\northoHeight = 750\nfieldHeight = 650\n\nenter, esc, space = 13, 27, 32\n\nwindow.onkeydown = lambda event: event.keyCode != space # Prevent scrolldown on spacebar press\n\nclass Attribute:    # Attribute in the gaming sense of the word, rather than of an object\n    def __init__ (self, game):\n        self.game = game                    # Attribute knows game it's part of\n        self.game.attributes.append (self)  # Game knows all its attributes\n        self.install ()                     # Put in place graphical representation of attribute\n        self.reset ()                       # Reset attribute to start position\n                \n    def reset (self):       # Restore starting positions or score, then commit to fabric\n        self.commit ()      # Nothing to restore for the Attribute base class\n                \n    def predict (self):\n        pass\n                \n    def interact (self):\n        pass\n        \n    def commit (self):\n        pass\n\nclass Sprite (Attribute):   # Here, a sprite is an attribute that can move\n    def __init__ (self, game, width, height):\n        self.width = width\n        self.height = height\n        Attribute.__init__ (self, game)\n        \n    def install (self):     # The sprite holds an image that fabric can display\n        self.image = __new__ (fabric.Rect ({\n            'width': self.game.scaleX (self.width), 'height': self.game.scaleY (self.height),\n            'originX': 'center', 'originY': 'center', 'fill': 'white'\n        }))\n        \n    __pragma__ ('kwargs')\n    def reset (self, vX = 0, vY = 0, x = 0, y = 0):\n        self.vX = vX        # Speed\n        self.vY = vY\n        \n        self.x = x          # Predicted position, can be commit, no bouncing initially\n        self.y = y\n        \n        Attribute.reset (self)\n    __pragma__ ('nokwargs')\n        \n    def predict (self):     # Predict position, do not yet commit, bouncing may alter it\n        self.x += self.vX * self.game.deltaT\n        self.y += self.vY * self.game.deltaT\n\n    def commit (self):      # Update fabric image for asynch draw\n        self.image.left = self.game.orthoX (self.x)\n        self.image.top = self.game.orthoY (self.y)\n        \n    def draw (self):\n        self.game.canvas.add (self.image)\n         \nclass Paddle (Sprite):\n    margin = 30 # Distance of paddles from walls\n    width = 10\n    height = 100\n    speed = 400 # / s\n    \n    def __init__ (self, game, index):\n        self.index = index  # Paddle knows its player index, 0 == left, 1 == right\n        Sprite.__init__ (self, game, self.width, self.height)\n        \n    def reset (self):       # Put paddle in rest position, dependent on player index\n        Sprite.reset (\n            self,\n            x = orthoWidth // 2 - self.margin if self.index else -orthoWidth // 2 + self.margin,\n            y = 0\n        )\n        \n    def predict (self): # Let paddle react on keys\n        self.vY = 0\n        \n        if self.index:                          # Right player\n            if self.game.keyCode == ord ('K'):  # Letter K pressed\n                self.vY = self.speed\n            elif self.game.keyCode == ord ('M'):\n                self.vY = -self.speed\n        else:                                   # Left player\n            if self.game.keyCode == ord ('A'):\n                self.vY = self.speed\n            elif self.game.keyCode == ord ('Z'):\n                self.vY = -self.speed\n                \n        Sprite.predict (self)                   # Do not yet commit, paddle may bounce with walls\n\n    def interact (self):    # Paddles and ball assumed infinitely thin\n        # Paddle touches wall\n        self.y = Math.max (self.height // 2 - fieldHeight // 2, Math.min (self.y, fieldHeight // 2 - self.height // 2))\n        \n        # Paddle hits ball\n        if (\n            (self.y - self.height // 2) < self.game.ball.y < (self.y + self.height // 2)\n            and (\n                (self.index == 0 and self.game.ball.x < self.x) # On or behind left paddle\n                or\n                (self.index == 1 and self.game.ball.x > self.x) # On or behind right paddle\n            )\n        ):\n            self.game.ball.x = self.x               # Ball may have gone too far already\n            self.game.ball.vX = -self.game.ball.vX  # Bounce on paddle\n            self.game.ball.speedUp (self)\n        \nclass Ball (Sprite):\n    side = 8\n    speed = 300 # / s\n    \n    def __init__ (self, game):\n        Sprite.__init__ (self, game, self.side, self.side)\n \n    def reset (self):   # Launch according to service direction with random angle offset from horizontal\n        angle =  (\n            self.game.serviceIndex * Math.PI    # Service direction\n            +\n            (1 if Math.random () > 0.5 else -1) * Math.random () * Math.atan (fieldHeight / orthoWidth)\n        )\n        \n        Sprite.reset (\n            self,\n            vX = self.speed * Math.cos (angle),\n            vY = self.speed * Math.sin (angle)\n        )\n        \n    def predict (self):\n        Sprite.predict (self)           # Integrate velocity to position\n        \n        if self.x < -orthoWidth // 2:   # If out on left side\n            self.game.scored (1)        #   Right player scored\n        elif self.x > orthoWidth // 2:\n            self.game.scored (0)\n            \n        if self.y > fieldHeight // 2:   # If it hits top wall\n            self.y = fieldHeight // 2   #   It may have gone too far already\n            self.vY = -self.vY          #   Bounce\n        elif self.y < -fieldHeight // 2:\n            self.y = -fieldHeight // 2\n            self.vY = -self.vY\n\n    def speedUp (self, bat):\n        factor = 1 + 0.15 * (1 - Math.abs (self.y - bat.y) / (bat.height // 2)) ** 2    # Speed will increase more if paddle hit near centre\n        \n        if Math.abs (self.vX) < 3 * self.speed:\n            self.vX *= factor\n            self.vY *= factor           \n\nclass Scoreboard (Attribute):\n    nameShift = 75\n    hintShift = 25\n            \n    def install (self): # Graphical representation of scoreboard are four labels and a separator line\n        self.playerLabels = [__new__ (fabric.Text ('Player {}'.format (name), {\n                'fill': 'white', 'fontFamily': 'arial', 'fontSize': '{}' .format (self.game.canvas.width / 30),\n                'left': self.game.orthoX (position * orthoWidth), 'top': self.game.orthoY (fieldHeight // 2 + self.nameShift)\n        })) for name, position in (('AZ keys:', -7/16), ('KM keys:', 1/16))]\n        \n        self.hintLabel = __new__ (fabric.Text ('[spacebar] starts game, [enter] resets score', {\n                'fill': 'white', 'fontFamily': 'arial', 'fontSize': '{}'.format (self.game.canvas.width / 70),\n                'left': self.game.orthoX (-7/16 * orthoWidth), 'top': self.game.orthoY (fieldHeight // 2 + self.hintShift)\n        }))\n        \n        self.image = __new__ (fabric.Line ([\n                self.game.orthoX (-orthoWidth // 2), self.game.orthoY (fieldHeight // 2),\n                self.game.orthoX (orthoWidth // 2), self.game.orthoY (fieldHeight // 2)\n            ],\n            {'stroke': 'white'}\n        ))\n                \n    def increment (self, playerIndex):\n        self.scores [playerIndex] += 1\n        \n    def reset (self):\n        self.scores = [0, 0]\n        Attribute.reset (self)  # Only does a commit here\n        \n    def commit (self):          # Committing labels is adapting their texts\n        self.scoreLabels = [__new__ (fabric.Text ('{}'.format (score), {\n                'fill': 'white', 'fontFamily': 'arial', 'fontSize': '{}'.format (self.game.canvas.width / 30),\n                'left': self.game.orthoX (position * orthoWidth), 'top': self.game.orthoY (fieldHeight // 2 + self.nameShift)\n        })) for score, position in zip (self.scores, (-2/16, 6/16))]\n\n    def draw (self):\n        for playerLabel, scoreLabel in zip (self.playerLabels, self.scoreLabels):\n            self.game.canvas.add (playerLabel)\n            self.game.canvas.add (scoreLabel)\n            self.game.canvas.add (self.hintLabel)\n        self.game.canvas.add (self.image)\n        \nclass Game:\n    def __init__ (self):\n        self.serviceIndex = 1 if Math.random () > 0.5 else 0    # Index of player that has initial service\n        self.pause = True                           # Start game in paused state\n        self.keyCode = None\n        \n        self.textFrame = document.getElementById ('text_frame')\n        self.canvasFrame = document.getElementById ('canvas_frame')\n        self.buttonsFrame = document.getElementById ('buttons_frame')\n        \n        self.canvas = __new__ (fabric.Canvas ('canvas', {'backgroundColor': 'black', 'originX': 'center', 'originY': 'center'}))\n        self.canvas.onWindowDraw = self.draw        # Install draw callback, will be called asynch\n        self.canvas.lineWidth = 2\n        self.canvas.clear ()    \n\n        self.attributes = []                        # All attributes will insert themselves here\n        self.paddles = [Paddle (self, index) for index in range (2)]    # Pass game as parameter self\n        self.ball = Ball (self)\n        self.scoreboard = Scoreboard (self)     \n\n        window.setInterval (self.update, 10)    # Install update callback, time in ms\n        window.setInterval (self.draw, 20)      # Install draw callback, time in ms\n        window.addEventListener ('keydown', self.keydown)\n        window.addEventListener ('keyup', self.keyup)\n        \n        self.buttons = []\n        \n        for key in ('A', 'Z', 'K', 'M', 'space', 'enter'):\n            button = document.getElementById (key)\n            button.addEventListener ('mousedown', (lambda aKey: lambda: self.mouseOrTouch (aKey, True)) (key))  # Returns inner lambda\n            button.addEventListener ('touchstart', (lambda aKey: lambda: self.mouseOrTouch (aKey, True)) (key))\n            button.addEventListener ('mouseup', (lambda aKey: lambda: self.mouseOrTouch (aKey, False)) (key))\n            button.addEventListener ('touchend', (lambda aKey: lambda: self.mouseOrTouch (aKey, False)) (key))\n            button.style.cursor = 'pointer'\n            button.style.userSelect = 'none'\n            self.buttons.append (button)\n            \n        self.time = + __new__ (Date)\n        \n        window.onresize = self.resize\n        self.resize ()\n        \n    def install (self):\n        for attribute in self.attributes:\n            attribute.install ()\n        \n    def mouseOrTouch (self, key, down):\n        if down:\n            if key == 'space':\n                self.keyCode = space\n            elif key == 'enter':\n                self.keyCode = enter\n            else:\n                self.keyCode = ord (key)\n        else:\n            self.keyCode = None\n \n    def update (self):                          # Note that update and draw are not synchronized\n        oldTime = self.time\n        self.time = + __new__ (Date)\n        self.deltaT = (self.time - oldTime) / 1000.\n        \n        if self.pause:                          # If in paused state\n            if self.keyCode == space:           #   If spacebar hit\n                self.pause = False              #         Start playing\n            elif self.keyCode == enter:         #   Else if enter hit\n                self.scoreboard.reset ()        #         Reset score\n        else:                                   # Else, so if in active state\n            for attribute in self.attributes:   #   Compute predicted values\n                attribute.predict ()\n            \n            for attribute in self.attributes:   #   Correct values for bouncing and scoring\n                attribute.interact ()\n            \n            for attribute in self.attributes:   #   Commit them to pyglet for display\n                attribute.commit ()\n            \n    def scored (self, playerIndex):             # Player has scored\n        self.scoreboard.increment (playerIndex) # Increment player's points\n        self.serviceIndex = 1 - playerIndex     # Grant service to the unlucky player\n        \n        for paddle in self.paddles:             # Put paddles in rest position\n            paddle.reset ()\n            \n        self.ball.reset ()                      # Put ball in rest position\n        self.pause = True                       # Wait for next round\n        \n    def commit (self):\n        for attribute in self.attributes:\n            attribute.commit ()\n        \n    def draw (self):\n        self.canvas.clear ()\n        for attribute in self.attributes:\n            attribute.draw ()\n             \n    def resize (self):\n        self.pageWidth = window.innerWidth\n        self.pageHeight = window.innerHeight\n        \n        self.textTop = 0\n\n        if self.pageHeight > 1.2 * self.pageWidth:\n            self.canvasWidth = self.pageWidth\n            self.canvasTop = self.textTop + 300\n        else:\n            self.canvasWidth = 0.6 * self.pageWidth\n            self.canvasTop = self.textTop + 200\n\n        self.canvasLeft = 0.5 * (self.pageWidth - self.canvasWidth)\n        self.canvasHeight = 0.6 * self.canvasWidth\n\n        self.buttonsTop = self.canvasTop + self.canvasHeight + 50\n        self.buttonsWidth = 500\n            \n        self.textFrame.style.top = self.textTop;\n        self.textFrame.style.left = self.canvasLeft + 0.05 * self.canvasWidth\n        self.textFrame.style.width = 0.9 * self.canvasWidth\n            \n        self.canvasFrame.style.top = self.canvasTop\n        self.canvasFrame.style.left = self.canvasLeft\n        self.canvas.setDimensions ({'width': self.canvasWidth, 'height': self.canvasHeight})\n        \n        self.buttonsFrame.style.top = self.buttonsTop\n        self.buttonsFrame.style.left = 0.5 * (self.pageWidth - self.buttonsWidth)\n        self.buttonsFrame.style.width = self.canvasWidth\n        \n        self.install ()\n        self.commit ()\n        self.draw ()\n        \n    def scaleX (self, x):\n        return x * (self.canvas.width / orthoWidth)\n            \n    def scaleY (self, y):\n        return y * (self.canvas.height / orthoHeight)   \n        \n    def orthoX (self, x):\n        return self.scaleX (x + orthoWidth // 2)\n        \n    def orthoY (self, y):\n        return self.scaleY (orthoHeight - fieldHeight // 2 - y)\n                \n    def keydown (self, event):\n        self.keyCode = event.keyCode\n        \n    def keyup (self, event):\n        self.keyCode = None \n        \ngame = Game ()  # Create and run game\n"
	],
	"mappings": "AAAA;AAMA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAMA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AAEA;AAGA;AAQA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAIA;AAMA;AAAA;AAGA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAKA;AAKA;AAAA;AAKA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}