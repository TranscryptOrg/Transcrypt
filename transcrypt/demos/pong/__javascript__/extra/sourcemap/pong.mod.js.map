{
	"version": 3,
	"file": "D:/activ_tosh/geatec/transcrypt/transcrypt/demos/pong/__javascript__/pong.mod.js",
	"sources": [
		"D:/activ_tosh/geatec/transcrypt/transcrypt/demos/pong/pong.py"
	],
	"sourcesContent": [
		"__pragma__ ('skip')\nwindow = Math = Date = 0\t# Prevent complaints by optional static checker\n__pragma__ ('noskip')\n\nfrom com.fabricjs import fabric\n\northoWidth = 1000\northoHeight = 750\nfieldHeight = 650\n\nenter, esc, space = 13, 27, 32\n\nclass Attribute:\t# Attribute in the gaming sense of the word, rather than of an object\n\tdef __init__ (self, game):\n\t\tself.game = game\t\t\t\t\t# Attribute knows game it's part of\n\t\tself.game.attributes.append (self)\t# Game knows all its attributes\n\t\tself.install ()\t\t\t\t\t\t# Put in place graphical representation of attribute\n\t\tself.reset ()\t\t\t\t\t\t# Reset attribute to start position\n\t\t\t\t\t\n\tdef reset (self):\t\t# Restore starting positions or score, then commit to fabric\n\t\tself.commit ()\t\t# Nothing to restore for the Attribute base class\n\t\t\t\t\n\tdef predict (self):\n\t\tpass\n\t\t\t\t\n\tdef interact (self):\n\t\tpass\n\t\t\n\tdef commit (self):\n\t\tpass\n\nclass Sprite (Attribute):\t# Here, a sprite is an attribute that can move\n\tdef __init__ (self, game, width, height):\n\t\tself.width = width\n\t\tself.height = height\n\t\tAttribute.__init__ (self, game)\n\t\t\n\tdef install (self):\t\t# The sprite holds an image that fabric can display\n\t\tself.image = __new__ (fabric.Rect ({\n\t\t\t'width': self.game.scaleX (self.width), 'height': self.game.scaleY (self.height),\n\t\t\t'originX': 'center', 'originY': 'center', 'fill': 'white'\n\t\t}))\n\t\t\n\t__pragma__ ('kwargs')\n\tdef reset (self, vX = 0, vY = 0, x = 0, y = 0):\n\t\tself.vX = vX\t\t# Speed\n\t\tself.vY = vY\n\t\t\n\t\tself.x = x\t\t\t# Predicted position, can be commit, no bouncing initially\n\t\tself.y = y\n\t\t\n\t\tAttribute.reset (self)\n\t__pragma__ ('nokwargs')\n\t\t\n\tdef predict (self):\t\t# Predict position, do not yet commit, bouncing may alter it\n\t\tself.x += self.vX * self.game.deltaT\n\t\tself.y += self.vY * self.game.deltaT\n\n\tdef commit (self):\t\t# Update fabric image for asynch draw\n\t\tself.image.left = self.game.orthoX (self.x)\n\t\tself.image.top = self.game.orthoY (self.y)\n\t\t\n\tdef draw (self):\n\t\tself.game.canvas.add (self.image)\n\t\t \nclass Paddle (Sprite):\n\tmargin = 30 # Distance of paddles from walls\n\twidth = 10\n\theight = 100\n\tspeed = 400 # / s\n\t\n\tdef __init__ (self, game, index):\n\t\tself.index = index\t# Paddle knows its player index, 0 == left, 1 == right\n\t\tSprite.__init__ (self, game, self.width, self.height)\n\t\t\n\tdef reset (self):\t\t# Put paddle in rest position, dependent on player index\n\t\tSprite.reset (\n\t\t\tself,\n\t\t\tx = orthoWidth // 2 - self.margin if self.index else -orthoWidth // 2 + self.margin,\n\t\t\ty = 0\n\t\t)\n\t\t\n\tdef predict (self): # Let paddle react on keys\n\t\tself.vY = 0\n\t\n\t\tif self.index:\t\t\t\t\t\t\t# Right player\n\t\t\tif ord ('K') in self.game.keySet:\t\t# Letter k pressed\n\t\t\t\tself.vY = self.speed\n\t\t\telif ord ('M') in self.game.keySet:\n\t\t\t\tself.vY = -self.speed\n\t\telse:\t\t\t  \t\t\t\t\t\t# Left player\n\t\t\tif ord ('A') in self.game.keySet:\n\t\t\t\tself.vY = self.speed\n\t\t\telif ord ('Z') in self.game.keySet:\n\t\t\t\tself.vY = -self.speed\n\t\t\t\t\n\t\tSprite.predict (self)\t\t\t\t\t# Do not yet commit, paddle may bounce with walls\n\n\tdef interact (self):\t# Paddles and ball assumed infinitely thin\n\t\t# Paddle touches wall\n\t\tself.y = Math.max (self.height // 2 - fieldHeight // 2, Math.min (self.y, fieldHeight // 2 - self.height // 2))\n\t\t\n\t\t# Paddle hits ball\n\t\tif (\n\t\t\t(self.y - self.height // 2) < self.game.ball.y < (self.y + self.height // 2)\n\t\t\tand (\n\t\t\t\t(self.index == 0 and self.game.ball.x < self.x) # On or behind left paddle\n\t\t\t\tor\n\t\t\t\t(self.index == 1 and self.game.ball.x > self.x) # On or behind right paddle\n\t\t\t)\n\t\t):\n\t\t\tself.game.ball.x = self.x\t\t\t\t# Ball may have gone too far already\n\t\t\tself.game.ball.vX = -self.game.ball.vX\t# Bounce on paddle\n\t\t\tself.game.ball.speedUp (self)\n\t\t\nclass Ball (Sprite):\n\tside = 8\n\tspeed = 300 # / s\n\t\n\tdef __init__ (self, game):\n\t\tSprite.__init__ (self, game, self.side, self.side)\n \n\tdef reset (self):\t# Launch according to service direction with random angle offset from horizontal\n\t\tangle =\t (\n\t\t\tself.game.serviceIndex * Math.PI\t# Service direction\n\t\t\t+\n\t\t\t(1 if Math.random () > 0.5 else -1) * Math.random () * Math.atan (fieldHeight / orthoWidth)\n\t\t)\n\t\t\n\t\tSprite.reset (\n\t\t\tself,\n\t\t\tvX = self.speed * Math.cos (angle),\n\t\t\tvY = self.speed * Math.sin (angle)\n\t\t)\n\t\t\n\tdef predict (self):\n\t\tSprite.predict (self)\t\t\t# Integrate velocity to position\n\t\t\n\t\tif self.x < -orthoWidth // 2:\t# If out on left side\n\t\t\tself.game.scored (1)\t\t#\tRight player scored\n\t\telif self.x > orthoWidth // 2:\n\t\t\tself.game.scored (0)\n\t\t\t\n\t\tif self.y > fieldHeight // 2:\t# If it hits top wall\n\t\t\tself.y = fieldHeight // 2\t#\tIt may have gone too far already\n\t\t\tself.vY = -self.vY\t\t\t#\tBounce\n\t\telif self.y < -fieldHeight // 2:\n\t\t\tself.y = -fieldHeight // 2\n\t\t\tself.vY = -self.vY\n\n\tdef speedUp (self, bat):\n\t\tfactor = 1 + 0.15 * (1 - Math.abs (self.y - bat.y) / (bat.height // 2)) ** 2\t# Speed will increase more if paddle hit near centre\n\t\t\n\t\tif Math.abs (self.vX) < 3 * self.speed:\n\t\t\tself.vX *= factor\n\t\t\tself.vY *= factor\t\t\t\n\nclass Scoreboard (Attribute):\n\tnameShift = 75\n\thintShift = 25\n\t\t\t\n\tdef install (self): # Graphical representation of scoreboard are four labels and a separator line\n\t\tself.playerLabels = [__new__ (fabric.Text ('Player {}'.format (name), {\n\t\t\t\t'fill': 'white', 'fontFamily': 'arial', 'fontSize': '30',\n\t\t\t\t'left': self.game.orthoX (position * orthoWidth), 'top': self.game.orthoY (fieldHeight // 2 + self.nameShift)\n\t\t})) for name, position in (('AZ keys:', -7/16), ('KM keys:', 1/16))]\n \t\t\n\t\tself.hintLabel = __new__ (fabric.Text ('[spacebar] starts game, [enter] resets score', {\n\t\t\t\t'fill': 'white', 'fontFamily': 'arial', 'fontSize': '12',\n\t\t\t\t'left': self.game.orthoX (-7/16 * orthoWidth), 'top': self.game.orthoY (fieldHeight // 2 + self.hintShift)\n\t\t}))\n\t\t\n\t\tself.image = __new__ (fabric.Line ([\n\t\t\t\tself.game.orthoX (-orthoWidth // 2), self.game.orthoY (fieldHeight // 2),\n\t\t\t\tself.game.orthoX (orthoWidth // 2), self.game.orthoY (fieldHeight // 2)\n\t\t\t],\n\t\t\t{'stroke': 'white'}\n\t\t))\n\t\t\t\t\n\tdef increment (self, playerIndex):\n\t\tself.scores [playerIndex] += 1\n\t\t\n\tdef reset (self):\n\t\tself.scores = [0, 0]\n\t\tAttribute.reset (self)\t# Only does a commit here\n\t\t\n\tdef commit (self):\t\t\t# Committing labels is adapting their texts\n\t\tself.scoreLabels = [__new__ (fabric.Text ('{}'.format (score), {\n\t\t\t\t'fill': 'white', 'fontFamily': 'arial', 'fontSize': '30',\n\t\t\t\t'left': self.game.orthoX (position * orthoWidth), 'top': self.game.orthoY (fieldHeight // 2 + self.nameShift)\n\t\t})) for score, position in zip (self.scores, (-2/16, 6/16))]\n\n\tdef draw (self):\n\t\tfor playerLabel, scoreLabel in zip (self.playerLabels, self.scoreLabels):\n\t\t\tself.game.canvas.add (playerLabel)\n\t\t\tself.game.canvas.add (scoreLabel)\n\t\t\tself.game.canvas.add (self.hintLabel)\n\t\tself.game.canvas.add (self.image)\n\t\t\nclass Game:\n\tdef __init__ (self):\n\t\tself.serviceIndex = 1 if Math.random () > 0.5 else 0\t# Index of player that has initial service\n\t\tself.pause = True\t\t\t\t\t\t\t# Start game in paused state\n\t\tself.keySet = set ()\n\t\t\n\t\tself.canvas = __new__ (fabric.Canvas ('canvas', {'backgroundColor': 'black', 'originX': 'center', 'originY': 'center'}))\n\t\tself.canvas.onWindowResize = self.resize\t# Install draw callback, will be called asynch\n\t\tself.canvas.onWindowDraw = self.draw\t\t# Install resize callback, will be called if resized\n\t\tself.canvas.lineWidth = 2\n\t\tself.canvas.clear ()\t\n\n\t\tself.attributes = []\t\t\t\t\t\t# All attributes will insert themselves here\n\t\tself.paddles = [Paddle (self, index) for index in range (2)]\t# Pass game as parameter self\n\t\tself.ball = Ball (self)\n\t\tself.scoreboard = Scoreboard (self)\t\t\n\n\t\twindow.setInterval (self.update, 10)\t# Install update callback, time in ms\n\t\twindow.setInterval (self.draw, 20)\t\t# Install draw callback, time in ms\n\t\twindow.addEventListener ('keydown', self.keydown)\n\t\twindow.addEventListener ('keyup', self.keyup)\n\t\t\n\t\tself.time = + __new__ (Date)\n \n\tdef update (self):\t\t\t\t\t\t\t# Note that update and draw are not synchronized\n\t\toldTime = self.time\n\t\tself.time = + __new__ (Date)\n\t\tself.deltaT = (self.time - oldTime) / 1000.\n\t\t\n\t\tif self.pause:\t\t\t\t\t\t\t# If in paused state\n\t\t\tif space in self.keySet:\t\t\t#\tIf spacebar hit\n\t\t\t\tself.pause = False\t\t\t\t#\t\t  Start playing\n\t\t\telif enter in self.keySet:\t\t#\tElse if enter hit\n\t\t\t\tself.scoreboard.reset ()\t\t#\t\t  Reset score\n\t\telse:\t\t\t\t\t\t\t\t\t# Else, so if in active state\n\t\t\tfor attribute in self.attributes:\t#\tCompute predicted values\n\t\t\t\tattribute.predict ()\n\t\t\t\n\t\t\tfor attribute in self.attributes:\t#\tCorrect values for bouncing and scoring\n\t\t\t\tattribute.interact ()\n\t\t\t\n\t\t\tfor attribute in self.attributes:\t#\tCommit them to pyglet for display\n\t\t\t\tattribute.commit ()\n\t\t\t\n\tdef scored (self, playerIndex):\t\t\t\t# Player has scored\n\t\tself.scoreboard.increment (playerIndex) # Increment player's points\n\t\tself.serviceIndex = 1 - playerIndex\t\t# Grant service to the unlucky player\n\t\t\n\t\tfor paddle in self.paddles:\t\t\t\t# Put paddles in rest position\n\t\t\tpaddle.reset ()\n\t\t\t\n\t\tself.ball.reset ()\t\t\t\t\t\t# Put ball in rest position\n\t\tself.pause = True\t\t\t\t\t\t# Wait for next round\n\t\t\n\tdef draw (self):\n\t\tself.canvas.clear ()\n\t\tfor attribute in self.attributes:\n\t\t\tattribute.draw ()\n\t\t\t \n\tdef resize (self, width, height):\n\t\tpass\n\t\t\n\tdef scaleX (self, x):\n\t\treturn x * (self.canvas.width / orthoWidth)\n\t\t\t\n\tdef scaleY (self, y):\n\t\treturn y * (self.canvas.height / orthoHeight)\t\n\t\t\n\tdef orthoX (self, x):\n\t\treturn self.scaleX (x + orthoWidth // 2)\n\t\t\n\tdef orthoY (self, y):\n\t\treturn self.scaleY (orthoHeight - fieldHeight // 2 - y)\n\t\t\t\t\n\tdef keydown (self, event):\n\t\tself.keySet.add (event.keyCode)\n\t\t\n\tdef keyup (self, event):\n\t\tself.keySet.remove (event.keyCode)\n\t\t\ngame = Game ()\t# Create and run game\n"
	],
	"mappings": "AAAA;AAIA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAMA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAMA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAEA;AAGA;AAQA;AACA;AACA;AAAA;AAAA;AAAA;AA/CA;AACA;AACA;AACA;AA8CA;AAIA;AACA;AAAA;AAEA;AAIA;AAMA;AAAA;AAGA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AArCA;AACA;AAwCA;AAIA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAKA;AAKA;AAAA;AAKA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAvCA;AACA;AAwCA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}