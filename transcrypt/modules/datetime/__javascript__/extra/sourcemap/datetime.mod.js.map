{
	"version": 3,
	"file": "D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/modules/datetime/__javascript__/datetime.mod.js",
	"sources": [
		"D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/modules/datetime/__init__.py"
	],
	"sourcesContent": [
		"\"\"\"Concrete date/time and related types.\n\nSee http://www.iana.org/time-zones/repository/tz-link.html for\ntime zone and DST data sources.\n\"\"\"\n\nimport time as _time\nimport math as _math\nfrom org.transcrypt.stubs.browser import __envir__\n\n\nif __envir__.executor_name == __envir__.transpiler_name:\n    # functions not imlemented in transcrypt\n    def divmod(n, d):\n        return n // d, n % d\n\n    def modf(n):\n        sign = 1 if n >= 0 else -1\n        f, mod = divmod(abs(n), 1)\n        return mod * sign, f * sign\n    _math.modf = modf\n\n\ndef zfill(s, c):\n    s = str(s)\n    if len(s) < c:\n        # __pragma__('opov')\n        return '0' * (c - len(s)) + s\n        # __pragma__('noopov')\n    else:\n        return s\n\n\ndef rjust(s, c):\n    s = str(s)\n    if len(s) < c:\n        # __pragma__('opov')\n        return ' ' * (c - len(s)) + s\n        # __pragma__('noopov')\n    else:\n        return s\n\n\ndef _cmp(x, y):\n    return 0 if x == y else 1 if x > y else -1\n\n\nMINYEAR = 1\nMAXYEAR = 9999\n_MAXORDINAL = 3652059  # date.max.toordinal()\n\n# Utility functions, adapted from Python's Demo/classes/Dates.py, which\n# also assumes the current Gregorian calendar indefinitely extended in\n# both directions.  Difference:  Dates.py calls January 1 of year 0 day\n# number 1.  The code here calls January 1 of year 1 day number 1.  This is\n# to match the definition of the \"proleptic Gregorian\" calendar in Dershowitz\n# and Reingold's \"Calendrical Calculations\", where it's the base calendar\n# for all computations.  See the book for algorithms for converting between\n# proleptic Gregorian ordinals and many other calendar systems.\n\n# -1 is a placeholder for indexing purposes.\n_DAYS_IN_MONTH = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n_DAYS_BEFORE_MONTH = [-1]  # -1 is a placeholder for indexing purposes.\ndbm = 0\nfor dim in _DAYS_IN_MONTH[1:]:\n    _DAYS_BEFORE_MONTH.append(dbm)\n    dbm += dim\ndel dbm, dim\n\n\ndef _is_leap(year):\n    \"\"\"year -> 1 if leap year, else 0.\"\"\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\n\ndef _days_before_year(year):\n    \"\"\"year -> number of days before January 1st of year.\"\"\"\n    y = year - 1\n    return y * 365 + y // 4 - y // 100 + y // 400\n\n\ndef _days_in_month(year, month):\n    \"\"\"year, month -> number of days in that month in that year.\"\"\"\n    assert 1 <= month <= 12, month\n    if month == 2 and _is_leap(year):\n        return 29\n    return _DAYS_IN_MONTH[month]\n\n\ndef _days_before_month(year, month):\n    \"\"\"year, month -> number of days in year preceding first day of month.\"\"\"\n    assert 1 <= month <= 12, 'month must be in 1..12'\n    return _DAYS_BEFORE_MONTH[month] + (month > 2 and _is_leap(year))\n\n\ndef _ymd2ord(year, month, day):\n    \"\"\"year, month, day -> ordinal, considering 01-Jan-0001 as day 1.\"\"\"\n    assert 1 <= month <= 12, 'month must be in 1..12'\n    dim = _days_in_month(year, month)\n    assert 1 <= day <= dim, ('day must be in 1..%d' % dim)\n    return (_days_before_year(year) +\n            _days_before_month(year, month) +\n            day)\n\n\n_DI400Y = _days_before_year(401)  # number of days in 400 years\n_DI100Y = _days_before_year(101)  # \"    \"   \"   \" 100   \"\n_DI4Y = _days_before_year(5)  # \"    \"   \"   \"   4   \"\n\n# A 4-year cycle has an extra leap day over what we'd get from pasting\n# together 4 single years.\nassert _DI4Y == 4 * 365 + 1\n\n# Similarly, a 400-year cycle has an extra leap day over what we'd get from\n# pasting together 4 100-year cycles.\nassert _DI400Y == 4 * _DI100Y + 1\n\n# OTOH, a 100-year cycle has one fewer leap day than we'd get from\n# pasting together 25 4-year cycles.\nassert _DI100Y == 25 * _DI4Y - 1\n\n\ndef _ord2ymd(n):\n    \"\"\"ordinal -> (year, month, day), considering 01-Jan-0001 as day 1.\"\"\"\n\n    # n is a 1-based index, starting at 1-Jan-1.  The pattern of leap years\n    # repeats exactly every 400 years.  The basic strategy is to find the\n    # closest 400-year boundary at or before n, then work with the offset\n    # from that boundary to n.  Life is much clearer if we subtract 1 from\n    # n first -- then the values of n at 400-year boundaries are exactly\n    # those divisible by _DI400Y:\n    #\n    #     D  M   Y            n              n-1\n    #     -- --- ----        ----------     ----------------\n    #     31 Dec -400        -_DI400Y       -_DI400Y -1\n    #      1 Jan -399         -_DI400Y +1   -_DI400Y      400-year boundary\n    #     ...\n    #     30 Dec  000        -1             -2\n    #     31 Dec  000         0             -1\n    #      1 Jan  001         1              0            400-year boundary\n    #      2 Jan  001         2              1\n    #      3 Jan  001         3              2\n    #     ...\n    #     31 Dec  400         _DI400Y        _DI400Y -1\n    #      1 Jan  401         _DI400Y +1     _DI400Y      400-year boundary\n    n -= 1\n    n400, n = divmod(n, _DI400Y)\n    year = n400 * 400 + 1  # ..., -399, 1, 401, ...\n\n    # Now n is the (non-negative) offset, in days, from January 1 of year, to\n    # the desired date.  Now compute how many 100-year cycles precede n.\n    # Note that it's possible for n100 to equal 4!  In that case 4 full\n    # 100-year cycles precede the desired day, which implies the desired\n    # day is December 31 at the end of a 400-year cycle.\n    n100, n = divmod(n, _DI100Y)\n\n    # Now compute how many 4-year cycles precede it.\n    n4, n = divmod(n, _DI4Y)\n\n    # And now how many single years.  Again n1 can be 4, and again meaning\n    # that the desired day is December 31 at the end of the 4-year cycle.\n    n1, n = divmod(n, 365)\n\n    year += n100 * 100 + n4 * 4 + n1\n    if n1 == 4 or n100 == 4:\n        assert n == 0\n        return year - 1, 12, 31\n\n    # Now the year is correct, and n is the offset from January 1.  We find\n    # the month via an estimate that's either exact or one too large.\n    leapyear = n1 == 3 and (n4 != 24 or n100 == 3)\n    assert leapyear == _is_leap(year)\n    month = (n + 50) >> 5\n    preceding = _DAYS_BEFORE_MONTH[month] + (month > 2 and leapyear)\n    if preceding > n:  # estimate is too large\n        month -= 1\n        preceding -= _DAYS_IN_MONTH[month] + (month == 2 and leapyear)\n    n -= preceding\n    assert 0 <= n < _days_in_month(year, month)\n\n    # Now the year and month are correct, and n is the offset from the\n    # start of that month:  we're done!\n    return year, month, n + 1\n\n\n# Month and day names.  For localized versions, see the calendar module.\n_MONTHNAMES = [None, \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n               \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n_DAYNAMES = [None, \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"]\n\n\ndef _build_struct_time(y, m, d, hh, mm, ss, dstflag):\n    wday = (_ymd2ord(y, m, d) + 6) % 7\n    dnum = _days_before_month(y, m) + d\n    # return _time.struct_time((y, m, d, hh, mm, ss, wday, dnum, dstflag))\n    return (y, m, d, hh, mm, ss, wday, dnum, dstflag)\n\n\ndef _format_time(hh, mm, ss, us):\n    # Skip trailing microseconds when us==0.\n    result = \"{}:{}:{}\".format(zfill(hh, 2), zfill(mm, 2), zfill(ss, 2))\n    if us:\n        result += \".{}\".format(zfill(us, 6))\n    return result\n\n\n# Correctly substitute for %z and %Z escapes in strftime formats.\ndef _wrap_strftime(object, format, timetuple):\n    # Don't call utcoffset() or tzname() unless actually needed.\n    freplace = None  # the string to use for %f\n    zreplace = None  # the string to use for %z\n    Zreplace = None  # the string to use for %Z\n\n    # Scan format for %z and %Z escapes, replacing as needed.\n    newformat = []\n    i, n = 0, len(format)\n    while i < n:\n        ch = format[i]\n        i += 1\n        if ch == '%':\n            if i < n:\n                ch = format[i]\n                i += 1\n                if ch == 'f':\n                    if freplace is None:\n                        freplace = '{}'.format(zfill(getattr(object, 'microsecond', 0), 6))\n                    newformat.append(freplace)\n                elif ch == 'z':\n                    if zreplace is None:\n                        zreplace = \"\"\n                        if hasattr(object, \"utcoffset\"):\n                            offset = object.utcoffset()\n                            if offset is not None:\n                                sign = '+'\n                                if offset.days < 0:\n                                    offset = -offset\n                                    sign = '-'\n                                h, m = divmod(offset, timedelta(hours=1))\n                                assert not m % timedelta(minutes=1), \"whole minute\"\n                                m //= timedelta(minutes=1)\n                                zreplace = '{}{}{}'.format(sign, zfill(h, 2), zfill(m, 2))\n                    assert '%' not in zreplace\n                    newformat.append(zreplace)\n                elif ch == 'Z':\n                    if Zreplace is None:\n                        Zreplace = \"\"\n                        if hasattr(object, \"tzname\"):\n                            s = object.tzname()\n                            if s is not None:\n                                # strftime is going to have at this: escape %\n                                Zreplace = s.replace('%', '%%')\n                    newformat.append(Zreplace)\n                else:\n                    newformat.append('%')\n                    newformat.append(ch)\n            else:\n                newformat.append('%')\n        else:\n            newformat.append(ch)\n    newformat = \"\".join(newformat)\n    return _time.strftime(newformat, timetuple)\n\n\n# Just raise TypeError if the arg isn't None or a string.\ndef _check_tzname(name):\n    if name is not None and not isinstance(name, str):\n        raise TypeError(\"tzinfo.tzname() must return None or string, \"\n                        \"not '{}'\".format(type(name)))\n\n\n# name is the offset-producing method, \"utcoffset\" or \"dst\".\n# offset is what it returned.\n# If offset isn't None or timedelta, raises TypeError.\n# If offset is None, returns None.\n# Else offset is checked for being in range, and a whole # of minutes.\n# If it is, its integer value is returned.  Else ValueError is raised.\ndef _check_utc_offset(name, offset):\n    assert name in (\"utcoffset\", \"dst\")\n    if offset is None:\n        return\n    if not isinstance(offset, timedelta):\n        raise TypeError(\"tzinfo.{}() must return None \"\n                        \"or timedelta, not '{}'\".format(name, type(offset)))\n    if offset.__mod__(timedelta(minutes=1)).microseconds or offset.microseconds:\n        raise ValueError(\"tzinfo.{}() must return a whole number \"\n                         \"of minutes, got {}\".format(name, offset))\n    # __pragma__('opov')\n    if not -timedelta(1) < offset < timedelta(1):\n        raise ValueError(\"{}()={}, must be must be strictly between \"\n                         \"-timedelta(hours=24) and timedelta(hours=24)\".format(name, offset))\n    # __pragma__('noopov')\n\n\ndef _check_int_field(value):\n    _type = type(value)\n    if _type == int:\n        return value\n    if not _type == float:\n        try:\n            value = value.__int__()\n        except AttributeError:\n            pass\n        else:\n            if type(value) == int:\n                return value\n            raise TypeError('__int__ returned non-int (type {})'.format(type(value).__name__))\n        raise TypeError('an integer is required (got type {})'.format(type(value).__name__))\n    raise TypeError('integer argument expected, got float')\n\n\ndef _check_date_fields(year, month, day):\n    year = _check_int_field(year)\n    month = _check_int_field(month)\n    day = _check_int_field(day)\n    if not MINYEAR <= year <= MAXYEAR:\n        raise ValueError('year must be in {}..{}'.format(MINYEAR, MAXYEAR), year)\n    if not 1 <= month <= 12:\n        raise ValueError('month must be in 1..12', month)\n    dim = _days_in_month(year, month)\n    if not 1 <= day <= dim:\n        raise ValueError('day must be in 1..{}'.format(dim), day)\n    return year, month, day\n\n\ndef _check_time_fields(hour, minute, second, microsecond):\n    hour = _check_int_field(hour)\n    minute = _check_int_field(minute)\n    second = _check_int_field(second)\n    microsecond = _check_int_field(microsecond)\n    if not 0 <= hour <= 23:\n        raise ValueError('hour must be in 0..23', hour)\n    if not 0 <= minute <= 59:\n        raise ValueError('minute must be in 0..59', minute)\n    if not 0 <= second <= 59:\n        raise ValueError('second must be in 0..59', second)\n    if not 0 <= microsecond <= 999999:\n        raise ValueError('microsecond must be in 0..999999', microsecond)\n    return hour, minute, second, microsecond\n\n\ndef _check_tzinfo_arg(tz):\n    if tz is not None and not isinstance(tz, tzinfo):\n        raise TypeError(\"tzinfo argument must be None or of a tzinfo subclass\")\n\n\ndef _cmperror(x, y):\n    raise TypeError(\"can't compare '{}' to '{}'\".format(\n        type(x).__name__, type(y).__name__))\n\n\ndef _divide_and_round(a, b):\n    \"\"\"divide a by b and round result to the nearest integer\n\n    When the ratio is exactly half-way between two integers,\n    the even integer is returned.\n    \"\"\"\n    # Based on the reference implementation for divmod_near\n    # in Objects/longobject.c.\n    q, r = divmod(a, b)\n    # round up if either r / b > 0.5, or r / b == 0.5 and q is odd.\n    # The expression r / b > 0.5 is equivalent to 2 * r > b if b is\n    # positive, 2 * r < b if b negative.\n    r *= 2\n    greater_than_half = r > b if b > 0 else r < b\n    if greater_than_half or r == b and q % 2 == 1:\n        q += 1\n\n    return q\n\n\nclass timedelta:\n    \"\"\"Represent the difference between two datetime objects.\n\n    Supported operators:\n\n    - add, subtract timedelta\n    - unary plus, minus, abs\n    - compare to timedelta\n    - multiply, divide by int\n\n    In addition, datetime supports subtraction of two datetime objects\n    returning a timedelta, and addition or subtraction of a datetime\n    and a timedelta giving a datetime.\n\n    Representation: (days, seconds, microseconds).  Why?  Because I\n    felt like it.\n    \"\"\"\n\n    # __pragma__('kwargs')\n    def __init__(self, days=0, seconds=0, microseconds=0,\n                milliseconds=0, minutes=0, hours=0, weeks=0):\n        # Doing this efficiently and accurately in C is going to be difficult\n        # and error-prone, due to ubiquitous overflow possibilities, and that\n        # C double doesn't have enough bits of precision to represent\n        # microseconds over 10K years faithfully.  The code here tries to make\n        # explicit where go-fast assumptions can be relied on, in order to\n        # guide the C implementation; it's way more convoluted than speed-\n        # ignoring auto-overflow-to-long idiomatic Python could be.\n\n        # XXX Check that all inputs are ints or floats.\n\n        # Final values, all integer.\n        # s and us fit in 32-bit signed ints; d isn't bounded.\n        d = s = us = 0\n\n        # Normalize everything to days, seconds, microseconds.\n        days += weeks * 7\n        seconds += minutes * 60 + hours * 3600\n        microseconds += milliseconds * 1000\n\n        # Get rid of all fractions, and normalize s and us.\n        # Take a deep breath <wink>.\n        if isinstance(days, float):\n            dayfrac, days = _math.modf(days)\n            daysecondsfrac, daysecondswhole = _math.modf(dayfrac * (24. * 3600.))\n            assert daysecondswhole == int(daysecondswhole)  # can't overflow\n            s = int(daysecondswhole)\n            assert days == int(days)\n            d = int(days)\n        else:\n            daysecondsfrac = 0.0\n            d = days\n        assert isinstance(daysecondsfrac, (float, int))\n        assert abs(daysecondsfrac) <= 1.0\n        assert isinstance(d, int)\n        assert abs(s) <= 24 * 3600\n        # days isn't referenced again before redefinition\n\n        if isinstance(seconds, float):\n            secondsfrac, seconds = _math.modf(seconds)\n            assert seconds == int(seconds)\n            seconds = int(seconds)\n            secondsfrac += daysecondsfrac\n            assert abs(secondsfrac) <= 2.0\n        else:\n            secondsfrac = daysecondsfrac\n        # daysecondsfrac isn't referenced again\n        assert isinstance(secondsfrac, (float, int))\n        assert abs(secondsfrac) <= 2.0\n\n        assert isinstance(seconds, int)\n        days, seconds = divmod(seconds, 24 * 3600)\n        d += days\n        s += int(seconds)  # can't overflow\n        assert isinstance(s, int)\n        assert abs(s) <= 2 * 24 * 3600\n        # seconds isn't referenced again before redefinition\n\n        usdouble = secondsfrac * 1e6\n        assert abs(usdouble) < 2.1e6  # exact value not critical\n        # secondsfrac isn't referenced again\n\n        if isinstance(microseconds, float):\n            microseconds = round(microseconds + usdouble)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24 * 3600)\n            d += days\n            s += seconds\n        else:\n            microseconds = int(microseconds)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24 * 3600)\n            d += days\n            s += seconds\n            microseconds = round(microseconds + usdouble)\n        assert isinstance(s, int)\n        assert isinstance(microseconds, int)\n        assert abs(s) <= 3 * 24 * 3600\n        assert abs(microseconds) < 3.1e6\n\n        # Just a little bit of carrying possible for microseconds and seconds.\n        seconds, us = divmod(microseconds, 1000000)\n        s += seconds\n        days, s = divmod(s, 24 * 3600)\n        d += days\n\n        assert isinstance(d, int)\n        assert isinstance(s, int) and 0 <= s < 24 * 3600\n        assert isinstance(us, int) and 0 <= us < 1000000\n\n        if abs(d) > 999999999:\n            raise OverflowError(\"timedelta # of days is too large: %d\" % d)\n\n        self._days = d\n        self._seconds = s\n        self._microseconds = us\n    # __pragma__('nokwargs')\n\n    def __repr__(self):\n        if self._microseconds:\n            return \"datetime.timedelta({}, {}, {})\".format(\n                                          self._days,\n                                          self._seconds,\n                                          self._microseconds)\n        if self._seconds:\n            return \"datetime.timedelta({}, {})\".format(\n                                      self._days,\n                                      self._seconds)\n        return \"datetime.timedelta({})\".format(self._days)\n\n    def __str__(self):\n        mm, ss = divmod(self._seconds, 60)\n        hh, mm = divmod(mm, 60)\n        s = \"{}:{}:{}\".format(hh, zfill(mm, 2), zfill(ss, 2))\n        if self._days:\n            def plural(n):\n                return n, abs(n) != 1 and \"s\" or \"\"\n\n            s = (\"{} day{}, \".format(plural(self._days))) + s\n        if self._microseconds:\n            s = s + \".{}\".format(zfill(self._microseconds, 6))\n        return s\n\n    def total_seconds(self):\n        \"\"\"Total seconds in the duration.\"\"\"\n        return ((self.days * 86400 + self.seconds) * 10 ** 6 +\n                self.microseconds) / 10 ** 6\n\n    # Read-only field accessors\n    @property\n    def days(self):\n        \"\"\"days\"\"\"\n        return self._days\n\n    @property\n    def seconds(self):\n        \"\"\"seconds\"\"\"\n        return self._seconds\n\n    @property\n    def microseconds(self):\n        \"\"\"microseconds\"\"\"\n        return self._microseconds\n\n    def __add__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days + other._days,\n                             self._seconds + other._seconds,\n                             self._microseconds + other._microseconds)\n        return NotImplemented\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days - other._days,\n                             self._seconds - other._seconds,\n                             self._microseconds - other._microseconds)\n        return NotImplemented\n\n    def __rsub__(self, other):\n        if isinstance(other, timedelta):\n            return -self + other\n        return NotImplemented\n\n    def __neg__(self):\n        # for CPython compatibility, we cannot use\n        # our __class__ here, but need a real timedelta\n        return timedelta(-self._days,\n                         -self._seconds,\n                         -self._microseconds)\n\n    def __pos__(self):\n        return self\n\n    def __abs__(self):\n        if self._days < 0:\n            # __pragma__('opov')\n            return -self\n            # __pragma__('noopov')\n        else:\n            return self\n\n    def __mul__(self, other):\n        if isinstance(other, int):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days * other,\n                             self._seconds * other,\n                             self._microseconds * other)\n        if isinstance(other, float):\n            usec = self._to_microseconds()\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(usec * a, b))\n        return NotImplemented\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def _to_microseconds(self):\n        return ((self._days * (24 * 3600) + self._seconds) * 1000000 +\n                self._microseconds)\n\n    def __floordiv__(self, other):\n        if not isinstance(other, (int, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec // other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, usec // other)\n\n    def __truediv__(self, other):\n        if not isinstance(other, (int, float, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec / other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, _divide_and_round(usec, other))\n        if isinstance(other, float):\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(b * usec, a))\n\n    def __mod__(self, other):\n        if isinstance(other, timedelta):\n            r = self._to_microseconds() % other._to_microseconds()\n            return timedelta(0, 0, r)\n        return NotImplemented\n\n    def __divmod__(self, other):\n        if isinstance(other, timedelta):\n            q, r = divmod(self._to_microseconds(),\n                          other._to_microseconds())\n            return q, timedelta(0, 0, r)\n        return NotImplemented\n\n    # Comparisons of timedelta objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) == 0\n        else:\n            return False\n\n    def __le__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) <= 0\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) < 0\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) >= 0\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) > 0\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other):\n        assert isinstance(other, timedelta)\n        return _cmp(self._to_microseconds(), other._to_microseconds())\n\n    def __bool__(self):\n        return (self._days != 0 or\n                self._seconds != 0 or\n                self._microseconds != 0)\n\n\n_td_min = timedelta(-999999999)\n_td_max = timedelta(days=999999999, hours=23, minutes=59, seconds=59,\n                          microseconds=999999)\n_td_resolution = timedelta(microseconds=1)\n# __pragma__ ('js', '{}', '''Object.defineProperty (timedelta, 'min', {get: function () {return _td_min;}})''')\n# __pragma__ ('js', '{}', '''Object.defineProperty (timedelta, 'max', {get: function () {return _td_max;}})''')\n# __pragma__ ('js', '{}', '''Object.defineProperty (timedelta, 'resolution', {get: function () {return _td_resolution;}})''')\n\n\nclass date:\n    \"\"\"Concrete date type.\n\n    Constructors:\n\n    __new__()\n    fromtimestamp()\n    today()\n    fromordinal()\n\n    Operators:\n\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__,\n    __add__, __radd__, __sub__ (add/radd only with timedelta arg)\n\n    Methods:\n\n    timetuple()\n    toordinal()\n    weekday()\n    isoweekday(), isocalendar(), isoformat()\n    ctime()\n    strftime()\n\n    Properties (readonly):\n    year, month, day\n    \"\"\"\n\n    # __pragma__('kwargs')\n    def __init__(self, year, month=None, day=None):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        year, month, day (required, base 1)\n        \"\"\"\n        year, month, day = _check_date_fields(year, month, day)\n        self._year = year\n        self._month = month\n        self._day = day\n    # __pragma__('nokwargs')\n\n    # Additional constructors\n\n    @classmethod\n    def fromtimestamp(cls, t):\n        \"Construct a date from a POSIX timestamp (like time.time()).\"\n        y, m, d, hh, mm, ss, weekday, jday, dst = _time.localtime(t)\n        return cls(y, m, d)\n\n    @classmethod\n    def today(cls):\n        \"Construct a date from time.time().\"\n        t = _time.time()\n        return cls.fromtimestamp(t)\n\n    @classmethod\n    def fromordinal(cls, n):\n        \"\"\"Contruct a date from a proleptic Gregorian ordinal.\n\n        January 1 of year 1 is day 1.  Only the year, month and day are\n        non-zero in the result.\n        \"\"\"\n        y, m, d = _ord2ymd(n)\n        return cls(y, m, d)\n\n    # Conversions to string\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\n\n        >>> dt = datetime(2010, 1, 1)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0)'\n\n        >>> dt = datetime(2010, 1, 1, tzinfo=timezone.utc)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)'\n        \"\"\"\n        return \"datetime.date({}, {}, {})\".format(\n                                      self._year,\n                                      self._month,\n                                      self._day)\n\n    # XXX These shouldn't depend on time.localtime(), because that\n    # clips the usable dates to [1970 .. 2038).  At least ctime() is\n    # easily done without using strftime() -- that's better too because\n    # strftime(\"%c\", ...) is locale specific.\n\n    def ctime(self):\n        \"\"\"Return ctime() style string.\"\"\"\n        weekday = self.toordinal() % 7 or 7\n        return \"{} {} {} 00:00:00 {}\".format(\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            rjust(self._day, 2), zfill(self._year, 4))\n\n    def strftime(self, fmt):\n        \"\"\"Format using strftime().\"\"\"\n        return _wrap_strftime(self, fmt, self.timetuple())\n\n    def __format__(self, fmt):\n        if not isinstance(fmt, str):\n            raise TypeError(\"must be str, not {}\".format(type(fmt).__name__))\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)\n\n    def isoformat(self):\n        \"\"\"Return the date formatted according to ISO.\n\n        This is 'YYYY-MM-DD'.\n\n        References:\n        - http://www.w3.org/TR/NOTE-datetime\n        - http://www.cl.cam.ac.uk/~mgk25/iso-time.html\n        \"\"\"\n        return \"{}-{}-{}\".format(zfill(self._year, 4), zfill(self._month, 2), zfill(self._day, 2))\n\n    def __str__(self):\n        return self.isoformat()\n\n    # Read-only field accessors\n    @property\n    def year(self):\n        \"\"\"year (1-9999)\"\"\"\n        return self._year\n\n    @property\n    def month(self):\n        \"\"\"month (1-12)\"\"\"\n        return self._month\n\n    @property\n    def day(self):\n        \"\"\"day (1-31)\"\"\"\n        return self._day\n\n    # Standard conversions, __eq__, __le__, __lt__, __ge__, __gt__ (and helpers)\n\n    def timetuple(self):\n        \"\"\"Return local time tuple compatible with time.localtime().\"\"\"\n        return _build_struct_time(self._year, self._month, self._day,\n                                  0, 0, 0, -1)\n\n    def toordinal(self):\n        \"\"\"Return proleptic Gregorian ordinal for the year, month and day.\n\n        January 1 of year 1 is day 1.  Only the year, month and day values\n        contribute to the result.\n        \"\"\"\n        return _ymd2ord(self._year, self._month, self._day)\n\n    # __pragma__('kwargs')\n    def replace(self, year=None, month=None, day=None):\n        \"\"\"Return a new date with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self._year\n        if month is None:\n            month = self._month\n        if day is None:\n            day = self._day\n        return date(year, month, day)\n    # __pragma__('nokwargs')\n\n    # Comparisons of date objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) == 0\n        return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) <= 0\n        return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) < 0\n        return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) >= 0\n        return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) > 0\n        return NotImplemented\n\n    def _cmp(self, other):\n        assert isinstance(other, date)\n        y, m, d = self._year, self._month, self._day\n        y2, m2, d2 = other._year, other._month, other._day\n        return _cmp('{}{}{}'.format(zfill(y, 4), zfill(m, 2), zfill(d, 2)),\n                    '{}{}{}'.format(zfill(y2, 4), zfill(m2, 2), zfill(d2, 2)))\n\n    # Computations\n\n    def __add__(self, other):\n        \"\"\"Add a date to a timedelta.\"\"\"\n        if isinstance(other, timedelta):\n            o = self.toordinal() + other.days\n            if 0 < o <= _MAXORDINAL:\n                return date.fromordinal(o)\n            raise OverflowError(\"result out of range\")\n        return NotImplemented\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        \"\"\"Subtract two dates, or a date and a timedelta.\"\"\"\n        if isinstance(other, timedelta):\n            # __pragma__('opov')\n            return self + timedelta(-other.days)\n            # __pragma__('noopov')\n        if isinstance(other, date):\n            days1 = self.toordinal()\n            days2 = other.toordinal()\n            # __pragma__('opov')\n            return timedelta(days1 - days2)\n            # __pragma__('noopov')\n        return NotImplemented\n\n    def weekday(self):\n        \"\"\"Return day of the week, where Monday == 0 ... Sunday == 6.\"\"\"\n        return (self.toordinal() + 6) % 7\n\n    # Day-of-the-week and week-of-the-year, according to ISO\n\n    def isoweekday(self):\n        \"\"\"Return day of the week, where Monday == 1 ... Sunday == 7.\"\"\"\n        # 1-Jan-0001 is a Monday\n        return self.toordinal() % 7 or 7\n\n    def isocalendar(self):\n        \"\"\"Return a 3-tuple containing ISO year, week number, and weekday.\n\n        The first ISO week of the year is the (Mon-Sun) week\n        containing the year's first Thursday; everything else derives\n        from that.\n\n        The first week is 1; Monday is 1 ... Sunday is 7.\n\n        ISO calendar algorithm taken from\n        http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm\n        (used with permission)\n        \"\"\"\n        year = self._year\n        week1monday = _isoweek1monday(year)\n        today = _ymd2ord(self._year, self._month, self._day)\n        # Internally, week and day have origin 0\n        week, day = divmod(today - week1monday, 7)\n        if week < 0:\n            year -= 1\n            week1monday = _isoweek1monday(year)\n            week, day = divmod(today - week1monday, 7)\n        elif week >= 52:\n            if today >= _isoweek1monday(year + 1):\n                year += 1\n                week = 0\n        return year, week + 1, day + 1\n\n    resolution = timedelta(days=1)\n\n\n_date_class = date  # so functions w/ args named \"date\" can get at the class\n\n_d_min = date(1, 1, 1)\n_d_max = date(9999, 12, 31)\n# __pragma__ ('js', '{}', '''Object.defineProperty (date, 'min', {get: function () {return _d_min;}})''')\n# __pragma__ ('js', '{}', '''Object.defineProperty (date, 'max', {get: function () {return _d_max;}})''')\n\n\nclass tzinfo:\n    \"\"\"Abstract base class for time zone info classes.\n\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    \"\"\"\n\n    def tzname(self, dt):\n        \"\"\"datetime -> string name of time zone.\"\"\"\n        raise NotImplementedError(\"tzinfo subclass must override tzname()\")\n\n    def utcoffset(self, dt):\n        \"\"\"datetime -> minutes east of UTC (negative for west of UTC)\"\"\"\n        raise NotImplementedError(\"tzinfo subclass must override utcoffset()\")\n\n    def dst(self, dt):\n        \"\"\"datetime -> DST offset in minutes east of UTC.\n\n        Return 0 if DST not in effect.  utcoffset() must include the DST\n        offset.\n        \"\"\"\n        raise NotImplementedError(\"tzinfo subclass must override dst()\")\n\n    def fromutc(self, dt):\n        \"\"\"datetime in UTC -> datetime in local time.\"\"\"\n\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        dtoff = dt.utcoffset()\n        if dtoff is None:\n            raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")\n\n        # See the long comment block at the end of this file for an\n        # explanation of this algorithm.\n        dtdst = dt.dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc() requires a non-None dst() result\")\n        delta = dtoff - dtdst\n        if delta:\n            dt += delta\n            dtdst = dt.dst()\n            if dtdst is None:\n                raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                                 \"results; cannot convert\")\n        return dt + dtdst\n\n\n_tzinfo_class = tzinfo\n\n\nclass time:\n    \"\"\"Time with time zone.\n\n    Constructors:\n\n    __new__()\n\n    Operators:\n\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__,\n\n    Methods:\n\n    strftime()\n    isoformat()\n    utcoffset()\n    tzname()\n    dst()\n\n    Properties (readonly):\n    hour, minute, second, microsecond, tzinfo\n    \"\"\"\n\n    # __pragma__('kwargs')\n    def __init__(self, hour=0, minute=0, second=0, microsecond=0, tzinfo=None):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        hour, minute (required)\n        second, microsecond (default to zero)\n        tzinfo (default to None)\n        \"\"\"\n        hour, minute, second, microsecond = _check_time_fields(\n            hour, minute, second, microsecond)\n        _check_tzinfo_arg(tzinfo)\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n    # __pragma__('nokwargs')\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    # Comparisons of time objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other, allow_mixed=True) == 0\n        else:\n            return False\n\n    def __le__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) <= 0\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) < 0\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) >= 0\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) > 0\n        else:\n            _cmperror(self, other)\n\n    # __pragma__('kwargs')\n    def _cmp(self, other, allow_mixed=False):\n        assert isinstance(other, time)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self.utcoffset()\n            otoff = other.utcoffset()\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            if allow_mixed:\n                return 2  # arbitrary non-zero value\n            else:\n                raise TypeError(\"cannot compare naive and aware times\")\n        # __pragma__('opov')\n        myhhmm = self._hour * 60 + self._minute - myoff // timedelta(minutes=1)\n        othhmm = other._hour * 60 + other._minute - otoff // timedelta(minutes=1)\n        # __pragma__('noopov')\n        return _cmp((myhhmm, self._second, self._microsecond),\n                    (othhmm, other._second, other._microsecond))\n    # __pragma__('nokwargs')\n\n    # Conversion to string\n\n    def _tzstr(self, sep=\":\"):\n        \"\"\"Return formatted timezone offset (+xx:xx) or None.\"\"\"\n        off = self.utcoffset()\n        if off is not None:\n            if off.days < 0:\n                sign = \"-\"\n                off = -off\n            else:\n                sign = \"+\"\n            hh, mm = divmod(off, timedelta(hours=1))\n            assert not mm % timedelta(minutes=1), \"whole minute\"\n            mm //= timedelta(minutes=1)\n            assert 0 <= hh < 24\n            off = \"{}{}{}{}\".format(sign, zfill(hh, 2), sep, zfill(mm, 2))\n        return off\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        if self._microsecond != 0:\n            s = \", {}, {}\".format(self._second, self._microsecond)\n        elif self._second != 0:\n            s = \", {}\".format(self._second)\n        else:\n            s = \"\"\n        s = \"datetime.time({}, {}{})\".format(self._hour, self._minute, s)\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:len(s)-1] + \", tzinfo={}\".format(self._tzinfo.__repr__()) + \")\"\n        return s\n\n    def isoformat(self):\n        \"\"\"Return the time formatted according to ISO.\n\n        This is 'HH:MM:SS.mmmmmm+zz:zz', or 'HH:MM:SS+zz:zz' if\n        self.microsecond == 0.\n        \"\"\"\n        s = _format_time(self._hour, self._minute, self._second,\n                         self._microsecond)\n        tz = self._tzstr()\n        if tz:\n            s += tz\n        return s\n\n    def __str__(self):\n        return self.isoformat()\n\n    def strftime(self, fmt):\n        \"\"\"Format using strftime().  The date part of the timestamp passed\n        to underlying strftime should not be used.\n        \"\"\"\n        # The year must be >= 1000 else Python's strftime implementation\n        # can raise a bogus exception.\n        timetuple = (1900, 1, 1,\n                     self._hour, self._minute, self._second,\n                     0, 1, -1)\n        return _wrap_strftime(self, fmt, timetuple)\n\n    def __format__(self, fmt):\n        if not isinstance(fmt, str):\n            raise TypeError(\"must be str, not %s\" % type(fmt).__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)\n\n    # Timezone functions\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset in minutes east of UTC (negative west of\n        UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(None)\n        _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(None)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (in minutes\n        eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(None)\n        _check_utc_offset(\"dst\", offset)\n        return offset\n\n    # __pragma__('kwargs')\n    def replace(self, hour=None, minute=None, second=None, microsecond=None,\n                tzinfo=True):\n        \"\"\"Return a new time with new values for the specified fields.\"\"\"\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        return time(hour, minute, second, microsecond, tzinfo)\n    # __pragma__('nokwargs')\n\n    resolution = timedelta(microseconds=1)\n\n\n_time_class = time  # so functions w/ args named \"time\" can get at the class\n\n_tm_min = time(0, 0, 0)\n_tm_max = time(23, 59, 59, 999999)\n# __pragma__ ('js', '{}', '''Object.defineProperty (time, 'min', {get: function () {return _tm_min;}})''')\n# __pragma__ ('js', '{}', '''Object.defineProperty (time, 'max', {get: function () {return _tm_max;}})''')\n\n\nclass datetime(date):\n    \"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints.\n    \"\"\"\n\n    # __pragma__('kwargs')\n    def __init__(self, year, month=None, day=None, hour=0, minute=0, second=0,\n                microsecond=0, tzinfo=None):\n        year, month, day = _check_date_fields(year, month, day)\n        hour, minute, second, microsecond = _check_time_fields(\n            hour, minute, second, microsecond)\n        _check_tzinfo_arg(tzinfo)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n    # __pragma__('nokwargs')\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    @classmethod\n    def _fromtimestamp(cls, t, utc, tz):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        frac, t = _math.modf(t)\n        us = round(frac * 1e6)\n        if us >= 1000000:\n            t += 1\n            us -= 1000000\n        elif us < 0:\n            t -= 1\n            us += 1000000\n\n        converter = _time.gmtime if utc else _time.localtime\n        y, m, d, hh, mm, ss, weekday, jday, dst = converter(t)\n        ss = min(ss, 59)  # clamp out leap seconds if the platform has them\n        return cls(y, m, d, hh, mm, ss, us, tz)\n\n    @classmethod\n    def fromtimestamp(cls, t, tz=None):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        _check_tzinfo_arg(tz)\n\n        result = cls._fromtimestamp(t, tz is not None, tz)\n        if tz is not None:\n            result = tz.fromutc(result)\n        return result\n\n    @classmethod\n    def utcfromtimestamp(cls, t):\n        \"\"\"Construct a naive UTC datetime from a POSIX timestamp.\"\"\"\n        return cls._fromtimestamp(t, True, None)\n\n    @classmethod\n    def now(cls, tz=None):\n        \"\"\"Construct a datetime from time.time() and optional time zone info.\"\"\"\n        t = _time.time()\n        return cls.fromtimestamp(t, tz)\n\n    @classmethod\n    def utcnow(cls):\n        \"\"\"Construct a UTC datetime from time.time().\"\"\"\n        t = _time.time()\n        return cls.utcfromtimestamp(t)\n\n    @classmethod\n    def combine(cls, date, time):\n        \"\"\"Construct a datetime from a given date and a given time.\"\"\"\n        if not isinstance(date, _date_class):\n            raise TypeError(\"date argument must be a date instance\")\n        if not isinstance(time, _time_class):\n            raise TypeError(\"time argument must be a time instance\")\n        return cls(date.year, date.month, date.day,\n                   time.hour, time.minute, time.second, time.microsecond,\n                   time.tzinfo)\n\n    def timetuple(self):\n        \"\"\"Return local time tuple compatible with time.localtime().\"\"\"\n        dst = self.dst()\n        if dst is None:\n            dst = -1\n        elif dst:\n            dst = 1\n        else:\n            dst = 0\n        return _build_struct_time(self.year, self.month, self.day,\n                                  self.hour, self.minute, self.second,\n                                  dst)\n\n    def timestamp(self):\n        \"\"\"Return POSIX timestamp as float\"\"\"\n        if self._tzinfo is None:\n            return _time.mktime((self.year, self.month, self.day,\n                                 self.hour, self.minute, self.second,\n                                 -1, -1, -1)) + self.microsecond / 1e6\n        else:\n            # __pragma__('opov')\n            return (self - _EPOCH).total_seconds()\n            # __pragma__('noopov')\n\n    def utctimetuple(self):\n        \"\"\"Return UTC time tuple compatible with time.gmtime().\"\"\"\n        offset = self.utcoffset()\n        if offset:\n            # __pragma__('opov')\n            self -= offset\n            # __pragma__('noopov')\n        y, m, d = self.year, self.month, self.day\n        hh, mm, ss = self.hour, self.minute, self.second\n        return _build_struct_time(y, m, d, hh, mm, ss, 0)\n\n    def date(self):\n        \"\"\"Return the date part.\"\"\"\n        return date(self._year, self._month, self._day)\n\n    def time(self):\n        \"\"\"Return the time part, with tzinfo None.\"\"\"\n        return time(self.hour, self.minute, self.second, self.microsecond)\n\n    def timetz(self):\n        \"\"\"Return the time part, with same tzinfo.\"\"\"\n        return time(self.hour, self.minute, self.second, self.microsecond,\n                    self._tzinfo)\n\n    # __pragma__('kwargs')\n    def replace(self, year=None, month=None, day=None, hour=None,\n                minute=None, second=None, microsecond=None, tzinfo=True):\n        \"\"\"Return a new datetime with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self.year\n        if month is None:\n            month = self.month\n        if day is None:\n            day = self.day\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        return datetime(year, month, day, hour, minute, second, microsecond,\n                        tzinfo)\n    # __pragma__('nokwargs')\n\n    # __pragma__('kwargs')\n    def astimezone(self, tz=None):\n        if tz is None:\n            if self.tzinfo is None:\n                raise ValueError(\"astimezone() requires an aware datetime\")\n\n            # __pragma__('opov')\n            ts = (self - _EPOCH) // timedelta(seconds=1)\n            # __pragma__('noopov')\n\n            localtm = _time.localtime(ts)\n            local = datetime(*(localtm[:6]))\n            if len(localtm) > 9:\n                # Extract TZ data if available\n                gmtoff = localtm[10]\n                zone = localtm[9]\n                tz = timezone(timedelta(seconds=gmtoff), zone)\n            else:\n                # Compute UTC offset and compare with the value implied\n                # by tm_isdst.  If the values match, use the zone name\n                # implied by tm_isdst.\n                # __pragma__('opov')\n                delta = local - datetime(*(_time.gmtime(ts)[:6]))\n                dst = _time.daylight and localtm[8] > 0\n                gmtoff = -(_time.altzone if dst else _time.timezone)\n                if delta == timedelta(seconds=gmtoff):\n                    tz = timezone(delta, _time.tzname[dst])\n                else:\n                    tz = timezone(delta)\n                # __pragma__('noopov')\n\n        elif not isinstance(tz, tzinfo):\n            raise TypeError(\"tz argument must be an instance of tzinfo\")\n\n        mytz = self.tzinfo\n        if mytz is None:\n            raise ValueError(\"astimezone() requires an aware datetime\")\n\n        if tz is mytz:\n            return self\n\n        # Convert self to UTC, and attach the new time zone object.\n        myoffset = self.utcoffset()\n        if myoffset is None:\n            raise ValueError(\"astimezone() requires an aware datetime\")\n        # __pragma__('opov')\n        utc = (self - myoffset).replace(tzinfo=tz)\n        # __pragma__('noopov')\n\n        # Convert from UTC to tz's local time.\n        return tz.fromutc(utc)\n    # __pragma__('nokwargs')\n\n    # Ways to produce a string.\n\n    def ctime(self):\n        \"\"\"Return ctime() style string.\"\"\"\n        weekday = self.toordinal() % 7 or 7\n        return \"{} {} {} {}:{}:{} {}\".format(\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            zfill(self._day, 2),\n            zfill(self._hour, 2), zfill(self._minute, 2), zfill(self._second, 2),\n            zfill(self._year, 4))\n\n    def isoformat(self, sep='T'):\n        \"\"\"Return the time formatted according to ISO.\n\n        This is 'YYYY-MM-DD HH:MM:SS.mmmmmm', or 'YYYY-MM-DD HH:MM:SS' if\n        self.microsecond == 0.\n\n        If self.tzinfo is not None, the UTC offset is also attached, giving\n        'YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM' or 'YYYY-MM-DD HH:MM:SS+HH:MM'.\n\n        Optional argument sep specifies the separator between date and\n        time, default 'T'.\n        \"\"\"\n        s = (\"{}-{}-{}{}\".format(zfill(self._year, 4), zfill(self._month, 2), zfill(self._day, 2), sep) +\n             _format_time(self._hour, self._minute, self._second,\n                          self._microsecond))\n        off = self.utcoffset()\n        if off is not None:\n            if off.days < 0:\n                sign = \"-\"\n                off = -off\n            else:\n                sign = \"+\"\n            hh, mm = divmod(off, timedelta(hours=1))\n            assert not mm % timedelta(minutes=1), \"whole minute\"\n            mm //= timedelta(minutes=1)\n            s += \"{}{}:{}\".format(sign, zfill(hh, 2), zfill(mm, 2))\n        return s\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        L = [self._year, self._month, self._day,  # These are never zero\n             self._hour, self._minute, self._second, self._microsecond]\n        if L[len(L)-1] == 0:\n            L.pop()\n        if L[len(L)-1] == 0:\n            L.pop()\n        s = \"datetime.datetime({})\".format(\", \".join(map(str, L)))\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:len(s)-1] + \", tzinfo={}\".format(self._tzinfo.__repr__()) + \")\"\n        return s\n\n    def __str__(self):\n        \"\"\"Convert to string, for str().\"\"\"\n        return self.isoformat(sep=' ')\n\n    @classmethod\n    def strptime(cls, date_string, format):\n        \"\"\"string, format -> new datetime parsed from a string (like time.strptime()).\"\"\"\n        return cls(*(_time.strptime(date_string, format)[:6]))\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset in minutes east of UTC (negative west of\n        UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(self)\n        _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(self)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (in minutes\n        eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(self)\n        _check_utc_offset(\"dst\", offset)\n        return offset\n\n    # Comparisons of datetime objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other, allow_mixed=True) == 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            return False\n\n    def __le__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) <= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) < 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) >= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) > 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other, allow_mixed=False):\n        assert isinstance(other, datetime)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self.utcoffset()\n            otoff = other.utcoffset()\n            base_compare = myoff == otoff\n\n        if base_compare:\n            s1 = '{}{}{}{}{}{}{}'.format(\n                zfill(self._year, 4), zfill(self._month, 2),\n                zfill(self._day, 2), zfill(self._hour, 2),\n                zfill(self._minute, 2), zfill(self._second, 2), zfill(self._microsecond, 6)\n            )\n            s2 = '{}{}{}{}{}{}{}'.format(\n                zfill(other._year, 4), zfill(other._month, 2),\n                zfill(other._day, 2), zfill(other._hour, 2),\n                zfill(other._minute, 2), zfill(other._second, 2), zfill(other._microsecond, 6)\n            )\n            return _cmp(s1, s2)\n        if myoff is None or otoff is None:\n            if allow_mixed:\n                return 2  # arbitrary non-zero value\n            else:\n                raise TypeError(\"cannot compare naive and aware datetimes\")\n        # XXX What follows could be done more efficiently...\n        # __pragma__('opov')\n        diff = self - other  # this will take offsets into account\n        # __pragma__('noopov')\n        if diff.days < 0:\n            return -1\n        return diff and 1 or 0\n\n    def __add__(self, other):\n        \"\"\"Add a datetime and a timedelta.\"\"\"\n        if not isinstance(other, timedelta):\n            return NotImplemented\n        delta = timedelta(self.toordinal(),\n                          hours=self._hour,\n                          minutes=self._minute,\n                          seconds=self._second,\n                          microseconds=self._microsecond)\n        # __pragma__('opov')\n        delta += other\n        # __pragma__('noopov')\n        hour, rem = divmod(delta.seconds, 3600)\n        minute, second = divmod(rem, 60)\n        if 0 < delta.days <= _MAXORDINAL:\n            return datetime.combine(date.fromordinal(delta.days),\n                                    time(hour, minute, second,\n                                         delta.microseconds,\n                                         tzinfo=self._tzinfo))\n        raise OverflowError(\"result out of range\")\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        \"\"\"Subtract two datetimes, or a datetime and a timedelta.\"\"\"\n        if not isinstance(other, datetime):\n            if isinstance(other, timedelta):\n                # __pragma__('opov')\n                return self + -other\n                # __pragma__('noopov')\n            return NotImplemented\n\n        days1 = self.toordinal()\n        days2 = other.toordinal()\n        secs1 = self._second + self._minute * 60 + self._hour * 3600\n        secs2 = other._second + other._minute * 60 + other._hour * 3600\n        base = timedelta(days1 - days2,\n                         secs1 - secs2,\n                         self._microsecond - other._microsecond)\n        if self._tzinfo is other._tzinfo:\n            return base\n        myoff = self.utcoffset()\n        otoff = other.utcoffset()\n        if myoff == otoff:\n            return base\n        if myoff is None or otoff is None:\n            raise TypeError(\"cannot mix naive and timezone-aware time\")\n        # __pragma__('opov')\n        return base + otoff - myoff\n        # __pragma__('noopov')\n\n    resolution = timedelta(microseconds=1)\n\n\n_dt_min = datetime(1, 1, 1)\n_dt_max = datetime(9999, 12, 31, 23, 59, 59, 999999)\n# __pragma__ ('js', '{}', '''Object.defineProperty (datetime, 'min', {get: function () {return _dt_min;}})''')\n# __pragma__ ('js', '{}', '''Object.defineProperty (datetime, 'max', {get: function () {return _dt_max;}})''')\n\n\ndef _isoweek1monday(year):\n    # Helper to calculate the day number of the Monday starting week 1\n    # XXX This could be done more efficiently\n    THURSDAY = 3\n    firstday = _ymd2ord(year, 1, 1)\n    firstweekday = (firstday + 6) % 7  # See weekday() above\n    week1monday = firstday - firstweekday\n    if firstweekday > THURSDAY:\n        week1monday += 7\n    return week1monday\n\n\n# Sentinel value to disallow None\n_Omitted = '@#$^&$^'\n\nclass timezone(tzinfo):\n\n    # __pragma__('kwargs')\n    def __init__(self, offset, name=_Omitted):\n        if not isinstance(offset, timedelta):\n            raise TypeError(\"offset must be a timedelta\")\n        if name is _Omitted:\n            if not offset:\n                # offset = timedelta(0)  # utc\n                offset = self.utc\n            name = None\n        elif not isinstance(name, str):\n            raise TypeError(\"name must be a string\")\n        # __pragma__('opov')\n        if not (self._minoffset <= offset <= self._maxoffset):\n            raise ValueError(\"offset must be a timedelta \"\n                             \"strictly between -timedelta(hours=24) and \"\n                             \"timedelta(hours=24).\")\n        # __pragma__('noopov')\n        if (offset.microseconds != 0 or offset.seconds % 60 != 0):\n            raise ValueError(\"offset must be a timedelta \"\n                             \"representing a whole number of minutes\")\n        self._offset = offset\n        self._name = name\n    # __pragma__('nokwargs')\n\n    # __pragma__('kwargs')\n    @classmethod\n    def _create(cls, offset, name=_Omitted):\n        return cls(offset, name)\n    # __pragma__('nokwargs')\n\n    def __eq__(self, other):\n        if type(other) != timezone:\n            return False\n        return self._offset == other._offset\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\n\n        >>> tz = timezone.utc\n        >>> repr(tz)\n        'datetime.timezone.utc'\n        >>> tz = timezone(timedelta(hours=-5), 'EST')\n        >>> repr(tz)\n        \"datetime.timezone(datetime.timedelta(-1, 68400), 'EST')\"\n        \"\"\"\n        if self is self.utc:\n            return 'datetime.timezone.utc'\n        if self._name is None:\n            return \"datetime.timezone({})\".format(self._offset.__repr__())\n        return \"datetime.timezone({}, {})\".format(self._offset.__repr__(), self._name.__repr__())\n\n    def __str__(self):\n        return self.tzname(None)\n\n    def utcoffset(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            return self._offset\n        raise TypeError(\"utcoffset() argument must be a datetime instance\"\n                        \" or None\")\n\n    def tzname(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            if self._name is None:\n                return self._name_from_offset(self._offset)\n            return self._name\n        raise TypeError(\"tzname() argument must be a datetime instance\"\n                        \" or None\")\n\n    def dst(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            return None\n        raise TypeError(\"dst() argument must be a datetime instance\"\n                        \" or None\")\n\n    def fromutc(self, dt):\n        if isinstance(dt, datetime):\n            if dt.tzinfo is not self:\n                raise ValueError(\"fromutc: dt.tzinfo \"\n                                 \"is not self\")\n            # __pragma__('opov')\n            return dt + self._offset\n            # __pragma__('noopov')\n        raise TypeError(\"fromutc() argument must be a datetime instance\"\n                        \" or None\")\n\n    _maxoffset = timedelta(hours=23, minutes=59)\n    # __pragma__('opov')\n    _minoffset = -timedelta(hours=23, minutes=59)\n    # __pragma__('noopov')\n\n    @staticmethod\n    def _name_from_offset(delta):\n        # __pragma__('opov')\n        if delta < timedelta(0):\n            sign = '-'\n            delta = -delta\n        else:\n            sign = '+'\n        hours, rest = divmod(delta, timedelta(hours=1))\n        minutes = rest // timedelta(minutes=1)\n        # __pragma__('noopov')\n        return 'UTC{}{}:{}'.format(sign, zfill(hours, 2), zfill(minutes, 2))\n\n_tz_utc = timezone._create(timedelta(0))\n_tz_min = timezone._create(timezone._minoffset)\n_tz_max = timezone._create(timezone._maxoffset)\n# __pragma__ ('js', '{}', '''Object.defineProperty (timezone, 'utc', {get: function () {return _tz_utc;}})''')\n# __pragma__ ('js', '{}', '''Object.defineProperty (timezone, 'min', {get: function () {return _tz_min;}})''')\n# __pragma__ ('js', '{}', '''Object.defineProperty (timezone, 'max', {get: function () {return _tz_max;}})''')\n\n_EPOCH = datetime(1970, 1, 1, tzinfo=timezone.utc)\n"
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAIA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AACA;AAYA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAKA;AAEA;AAAA;AAGA;AAEA;AACA;AAAA;AAGA;AAAA;AAGA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;AAGA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AAeA;AAAA;AAwBA;AAAA;AAAA;AACA;AAOA;AAAA;AAAA;AAGA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAGA;AAAA;AAEA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAIA;AAAA;AAIA;AAEA;AAGA;AACA;AACA;AAEA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAIA;AAEA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAEA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AAAA;AAAA;AAAA;AAGA;AAQA;AAAA;AAAA;AAAA;AAKA;AACA;AAAA;AAAA;AAGA;AAAA;AAGA;AAkBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AAGA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AAAA;AAIA;AAGA;AAAA;AAEA;AAGA;AAAA;AAEA;AAGA;AAAA;AAEA;AACA;AAGA;AAAA;AAGA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAGA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAGA;AAAA;AAIA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAGA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AAEA;AACA;AACA;AACA;AAGA;AA6BA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAIA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAGA;AACA;AAAA;AAEA;AAOA;AAAA;AAAA;AAAA;AACA;AAAA;AAIA;AAWA;AAAA;AAUA;AAEA;AAIA;AAAA;AAEA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AASA;AAAA;AAEA;AACA;AAAA;AAGA;AAGA;AAAA;AAEA;AAGA;AAAA;AAEA;AAGA;AAAA;AAIA;AAEA;AAAA;AAGA;AAMA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAIA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAEA;AAAA;AAIA;AAGA;AAAA;AAEA;AAaA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AAGA;AAAA;AAMA;AAEA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAEA;AAMA;AAAA;AAAA;AAAA;AAEA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAGA;AAGA;AAwBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AAAA;AAEA;AAGA;AAAA;AAEA;AAGA;AAAA;AAEA;AAGA;AAAA;AAEA;AAGA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAEA;AAIA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAMA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AAMA;AAGA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAIA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAOA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AASA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AAGA;AAOA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AAAA;AAEA;AAGA;AAAA;AAEA;AAGA;AAAA;AAEA;AAGA;AAAA;AAEA;AAGA;AAAA;AAEA;AAMA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAMA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAGA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAGA;AACA;AAAA;AAEA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAIA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAIA;AAEA;AACA;AAAA;AAGA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAEA;AAAA;AAEA;AAEA;AAAA;AAEA;AAEA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAIA;AACA;AAIA;AAEA;AAMA;AAAA;AAEA;AAAA;AAAA;AAAA;AAaA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAEA;AAAA;AAEA;AAGA;AAAA;AAEA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAOA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AASA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAIA;AAKA;AAEA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AACA;AAMA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAGA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAIA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAUA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAIA;AAEA;AAEA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}