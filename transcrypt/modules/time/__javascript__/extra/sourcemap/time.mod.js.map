{
	"version": 3,
	"file": "D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/modules/time/__javascript__/time.mod.js",
	"sources": [
		"D:/activ_tosh/geatec/transcrypt/qquick/Transcrypt/transcrypt/modules/time/__init__.py"
	],
	"sourcesContent": [
		"\"\"\"\ntime module\n\nNo:\n\n- Platform specific functions\n- sleep. In js currently not possible in browsers\n         except via busy loops, we don't do that.\n- struct_time CLASS. we work only via the tuple interface of it.\n- handling of weird stuff.\n    e.g.: In Europe/Simferopool (Ukraine) the UTC offset before 1924 was +2.67\n\nSpec for all below (must have open to read this module):\n\n> https://docs.python.org/3.5/library/time.html\n\n\nJul 2016, Gunther Klessinger, Axiros GmbH\n\"\"\"\n# we don't need those:\n__pragma__ ('nokwargs')\n\n\n# for js dates:\nfrom org.transcrypt.stubs.browser import __new__\n\n# js date object. might be modified during calculations:\n__date = __new__(Date(0))\n__now = __new__(Date())\n\n\n# build the locale's weekday names\n__weekdays = []\n__weekdays_long = []\n__d = __new__(Date(1467662339080)) # a monday\nfor i in range(7):\n    for l, s in (__weekdays, 'short'), (__weekdays_long, 'long'):\n        l.append(__d.toLocaleString(window.navigator.language,\n                                        {'weekday': s}).lower())\n    __d.setDate(__d.getDate() + 1)\n\n\n# build the locale's months names\n__months = []\n__months_long = []\n__d = __new__(Date(946681200000.0)) # 1.1.2000\nfor i in range(12):\n    for l, s in ((__months, 'short'), (__months_long, 'long')):\n        l.append(__d.toLocaleString(window.navigator.language,\n                                        {'month': s}).lower())\n    __d.setMonth(__d.getMonth() + 1)\n\n\n\n# lookup for positions directives in struct_time tuples:\n# its a 9-sequence\n#        time.struct_time(tm_year=2016, tm_mon=7, tm_mday=19, tm_hour=2,\n#                         tm_min=24, tm_sec=2, tm_wday=1, tm_yday=201,\n#                         tm_isdst=1)\n__lu = {'Y': 0, 'm': 1, 'd': 2, 'H': 3, 'M': 4, 'S': 5}\n\ndef _lsplit(s, sep, maxsplit):\n    \"\"\" not yet in TS \"\"\"\n    if maxsplit == 0:\n        return [s]\n    split = s.split(sep)\n    if not maxsplit:\n        return split\n    ret = split.slice(0, maxsplit, 1)\n    if len(ret) == len(split):\n        return ret\n    ret.append(sep.join(split[maxsplit:]))\n    return ret\n\n\ndef _local_time_tuple(jd):\n    \"\"\" jd: javascript Date object, from unixtimestamp \"\"\"\n    res =  ( jd.getFullYear()\n            ,jd.getMonth() + 1 # zero based\n            ,jd.getDate()\n            ,jd.getHours()\n            ,jd.getMinutes()\n            ,jd.getSeconds()\n            ,jd.getDay() - 1 if jd.getDay() > 0 else 6\n            ,_day_of_year(jd, True)\n            ,_daylight_in_effect(jd)\n            ,jd.getMilliseconds() # not in use by the pub API\n           )\n    return res\n\ndef _utc_time_tuple(jd):\n    \"\"\" jd: javascript Date object, from unixtimestamp \"\"\"\n    res =  ( jd.getUTCFullYear()\n            ,jd.getUTCMonth() + 1 # zero based\n            ,jd.getUTCDate()\n            ,jd.getUTCHours()\n            ,jd.getUTCMinutes()\n            ,jd.getUTCSeconds()\n            ,jd.getUTCDay() - 1\n            ,_day_of_year(jd, False)\n            ,0 # is dst for utc: 0\n            ,jd.getUTCMilliseconds()\n           )\n    return res\n\ndef _day_of_year(jd, local):\n    # check if jd hours are ahead of UTC less than the offset to it:\n    day_offs = 0\n    if jd.getHours() + jd.getTimezoneOffset() * 60 / 3600 < 0:\n        day_offs = -1\n    was = jd.getTime()\n    cur = jd.setHours(23)\n    jd.setUTCDate(1)\n    jd.setUTCMonth(0)\n    jd.setUTCHours(0)\n    jd.setUTCMinutes(0)\n    jd.setUTCSeconds(0)\n    res = round((cur - jd) / 86400000 )\n    #res = round(((jd.setHours(23) - new Date(jd.getYear(), 0, 1, 0, 0, 0)\n    #                 ) / 1000 / 60 / 60 / 24))\n    if not local:\n        res += day_offs\n\n    if res == 0:\n        res = 365\n        jd.setTime(jd.getTime() - 86400)\n        last_year = jd.getUTCFullYear()\n        if _is_leap(last_year):\n            res = 366\n    jd.setTime(was)\n    return res\n\ndef _is_leap(year):\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\ndef __jan_jun_tz(t, func):\n    \"\"\" information about local jan and jun month of a t's year\n    default is to deliver timezone offset, but a function can be handed to us,\n    which we'll run on those two months\n    \"\"\"\n    # required to detect dst (daylight saving time) in effect:\n    was = t.getTime() # avoid new date objs\n    t.setDate(1)\n    res = []\n    for m in 0, 6:\n        t.setMonth(m)\n        if not func:\n            res.append(t.getTimezoneOffset())\n        else:\n            res.append(func(t))\n    t.setTime(was)\n    return res\n\ndef _daylight(t):\n    \"\"\"\n    http://stackoverflow.com/questions/11887934/\n    check-if-daylight-saving-time-is-in-effect-and-if-it-is-for-how-many-hours\n\n    return 0 or 1 like python\n    CAUTION: https://docs.python.org/2/library/time.html#time.daylight:\n    \"Nonzero if a DST timezone is DEFINED.\" (but not necessarily in effect!!)\n    -> we just check if there is a delta of tz offsets in june an jan of the\n    year of t:\n    \"\"\"\n    jj = __jan_jun_tz(t)\n    if jj[0] != jj[1]:\n        # daylight saving is DEFINED, since there's a difference in tz offsets\n        # in jan and jun, in the year of t:\n        return 1\n    return 0\n\ndef _daylight_in_effect(t):\n    jj = __jan_jun_tz(t)\n    if min(jj[0], jj[1]) == t.getTimezoneOffset():\n        return 1\n    return 0\n\ndef _timezone(t):\n    jj = __jan_jun_tz(t)\n    # in southern hemisphere the daylight saving is in winter months!\n    return max(jj[0], jj[1])\n\n\ndef __tzn(t):\n    # depending on browser ? new Date() -> Wed Jul... (CEST)\n    try:\n        return str(t).split('(')[1].split(')')[0]\n    except:\n        # better no crash:\n        return 'n.a.'\n\ndef _tzname(t):\n    '''the first is the name of the local non-DST timezone,\n\tthe second is the name of the local DST timezone.'''\n    cn = __tzn(t)\n    ret = [cn, cn]\n    jj = __jan_jun_tz(t, __tzn)\n    ind = 0\n    if not _daylight_in_effect(t):\n        ind = 1\n    for i in jj:\n        if i != cn:\n            ret[ind] = i\n    return tuple(ret)\n\n\n\n\n# ------------------------------------------------------------------ Public API\n\n# we calc those only once. I mean - we run in the browser in the end.\n\naltzone = __now.getTimezoneOffset()\nif not _daylight_in_effect(__now):\n    # then we must use the other offset we have in the current year:\n    _jj  = __jan_jun_tz(__now)\n    altzone = _jj[0] if altzone == _jj[1] else _jj[1]\naltzone = altzone * 60\n\ntimezone = _timezone(__now) * 60\n\ndaylight = _daylight(__now)\n\ntzname   = _tzname(__now)\n\n\ndef time():\n    \"\"\"\n    time() -> floating point number\\n\\nReturn the current time in seconds\n    since the Epoch.\n    Fractions of a second may be present if the system clock provides them.\n    \"\"\"\n    return Date.now() / 1000\n\n\ndef asctime(t):\n    return strftime('%a %b %d %H:%M:%S %Y', t)\n\n\ndef mktime(t):\n    ''' inverse of localtime '''\n    d = __new__(Date(t[0], t[1] - 1, t[2], t[3], t[4], t[5], 0))\n    return (d - 0) / 1000\n\n\ndef ctime(seconds):\n    \"\"\"\n    ctime(seconds) -> string\n\n    Convert a time in seconds since the Epoch to a string in local time.\n    This is equivalent to asctime(localtime(seconds)). When the time tuple is\n    not present, current time as returned by localtime() is used.'\n    \"\"\"\n    if not seconds:\n        seconds = time()\n    return asctime(localtime(seconds))\n\n\ndef localtime(seconds):\n    \"\"\"\n    localtime([seconds]) -> (tm_year,tm_mon,tm_mday,tm_hour,tm_min,\n                          tm_sec,tm_wday,tm_yday,tm_isdst)\n\n    Convert seconds since the Epoch to a time tuple expressing local time.\n    When 'seconds' is not passed in, convert the current time instead.\n    \"\"\"\n    if not seconds:\n        seconds = time()\n    return gmtime(seconds, True)\n\n\ndef gmtime(seconds, localtime):\n    \"\"\"\n    localtime([seconds]) -> (tm_year,tm_mon,tm_mday,tm_hour,tm_min,\n                          tm_sec,tm_wday,tm_yday,tm_isdst)\n\n    Convert seconds since the Epoch to a time tuple expressing local time.\n    When 'seconds' is not passed in, convert the current time instead.\n    \"\"\"\n    if not seconds:\n        seconds = time()\n    millis = seconds * 1000\n    __date.setTime(millis)\n    if localtime:\n        t = _local_time_tuple(__date)\n    else:\n        t = _utc_time_tuple(__date)\n    return t[:9]\n\n# ----------------------------------------------------------------------------\n# now the workhorses:\ndef strptime(string, format):\n    \"\"\"\n    strptime(string, format) -> struct_time\n\n    Parse a string to a time tuple according to a format specification.\n    See the library reference manual for formatting codes (same as\n            strftime()).\n\n    Commonly used format codes:\n\n        %Y  Year with century as a decimal number.\n        %m  Month as a decimal number [01,12].\n        %d  Day of the month as a decimal number [01,31].\n        %H  Hour (24-hour clock) as a decimal number [00,23].\n        %M  Minute as a decimal number [00,59].\n        %S  Second as a decimal number [00,61].\n        %z  Time zone offset from UTC.\n        %a  Locale's abbreviated weekday name.\n        %A  Locale's full weekday name.\n        %b  Locale's abbreviated month name.\n        %B  Locale's full month name.\n        %c  Locale's appropriate date and time representation.\n        %I  Hour (12-hour clock) as a decimal number [01,12].\n        %p  Locale's equivalent of either AM or PM.\n\n        Tradoffs of this Transcrypt implementation:\n\n        1. platform specific codes not supported\n        2. %% and %c not supported\n        \"\"\"\n\n    if not format:\n        format = \"%a %b %d %H:%M:%S %Y\"\n    ts, fmt = string, format\n    def get_next(fmt):\n        ''' returns next directive, next seperator, rest of format str'''\n        def get_sep(fmt):\n            res = []\n            if not fmt:\n                return '', ''\n            for i in range(len(fmt)-1):\n                c = fmt[i]\n                if c == '%':\n                    break\n                res.append(c)\n            return ''.join(res), fmt[i:]\n\n        # return next seperator:\n        d, sep, f = None, None, None\n        if fmt:\n            if fmt[0] == '%':\n                d = fmt[1]\n                sep, f = get_sep(fmt[2:])\n            else:\n                sep, f = get_sep(fmt)\n        return d, sep, f\n\n    # directive / value tuples go in here:\n    dir_val = {}\n    while ts:\n        d, sep, fmt = get_next(fmt)\n        if sep == '':\n            lv = None\n            if d:\n                # we have a directive, seperator is empty. Is the directive\n                # fixed length, with next w/o sep? e.g. %Y%Z ?\n                # then get the next one like:\n                l = -1\n                if   d == 'Y': l = 4\n                elif d == 'a': l = len(__weekdays[0])\n                elif d == 'A': l = len(__weekdays_long[0])\n                elif d == 'b': l = len(__months[0])\n                elif d in ('d', 'm', 'H', 'M', 'S'):\n                    l = 2\n                if l > -1:\n                    lv = [ts[:l], ts[l:]]\n            if not lv:\n                lv = [ts, '']\n        else:\n            lv = _lsplit(ts, sep, 1)\n        if d == None:\n            ts = lv[1]\n            continue\n        ts, dir_val[d] = lv[1], lv[0]\n        if fmt == '':\n            break\n    # defaults when not specified:\n    t = [1900, 1, 1, 0, 0, 0, 0, 1, -1]\n    ignore_keys = []\n    have_weekday = False\n    for d, v in dir_val.items():\n        if d in ignore_keys:\n            continue\n\n        if d == 'p':\n            continue\n\n        if d in __lu.keys():\n            t[__lu[d]] = int(v)\n            continue\n\n        if d in ('a', 'A', 'b', 'B'):\n            v = v.lower()\n\n        if d == 'm':\n            # we go the python 2(!) way for conflicting %b %m and take %m\n            # why? because there IS no Py3 way (see strp time testlet)\n            ignore_keys.append('b')\n            ignore_keys.append('B')\n\n        # better readable than short:\n        if d == 'a':\n            # funny. the weekday is only set but does not override %d.\n            # -> produces impossible dates but well its how py does it:\n            if not v in __weekdays:\n                raise ValueError('Weekday unknown in your locale')\n            have_weekday = True\n            t[6] = __weekdays.index(v)\n\n        elif d == 'A':\n            if not v in __weekdays_long:\n                raise ValueError('Weekday unknown in your locale')\n            have_weekday = True\n            t[6] = __weekdays_long.index(v)\n\n        elif d == 'b':\n            # month short. overruled by m if present\n            if not v in __months:\n                raise ValueError('Month unknown in your locale')\n            t[1] = __months.index(v) + 1\n\n        elif d == 'B':\n            # month long. overruled by m if present\n            if not v in __months_long:\n                raise ValueError('Month unknown in your locale')\n            t[1] = __months_long.index(v) + 1\n\n\n        elif d == 'I':\n            # 0-12 hour, with AM/PM.\n            ampm = dir_val['p'] or 'am'\n            ampm = ampm.lower()\n            v = int(v)\n            # thats how py does it\n            if v == 12:\n                v = 0\n            elif v > 12:\n                raise ValueError(\"time data '\" + string + \\\n                        \"' does not match format '\" + format + \"'\")\n            if ampm == 'pm':\n                v += 12\n            t[__lu['H']] = v\n\n        elif d == 'y':\n            t[0] = 2000 + int(v) # producing a y3k problem. try find me, then.\n\n        elif d == 'Z':\n            if v.lower() in ['gmt', 'utc']:\n                t[-1] = 0\n\n    # get day of year, costing us an object, to stay safe:\n    __date = __new__(Date(0))\n    __date.setUTCFullYear( t[0] )\n    __date.setUTCMonth(t[1] -1 )\n    __date.setUTCDate( t[2] )\n    __date.setUTCHours(t[3])\n    t[7] = _day_of_year(__date)\n    if not have_weekday:\n        t[6] = __date.getUTCDay() -1\n\n    return t\n\n\ndef strftime(format, t):\n    def zf2(v):\n        ''' zfill missing '''\n        if v < 10:\n            return '0' + str(v)\n        return v\n\n    if not t:\n        t = localtime()\n\n    f = format\n    for d in __lu.keys():\n        k = '%' + d\n        if not k in f:\n            continue\n        v = zf2(t[__lu[d]])\n        f = f.replace(k, v)\n    for d, l, pos in (('b', __months  , 1), ('B', __months_long  , 1),\n                      ('a', __weekdays, 6), ('A', __weekdays_long, 6)):\n        p = t[pos]\n        if pos == 1:\n            p = p -1\n        v = l[p].capitalize()\n        f = f.replace('%' + d, v)\n\n    if '%p' in f:\n        if t[3] > 11:\n            ap = 'PM'\n        else:\n            ap = 'AM'\n        f = f.replace('%p', ap)\n\n    if '%y' in f:\n        f = f.replace('%y', str(t[0])[-2:])\n\n    if '%I' in f:\n        v = t[3]\n        if v == 0:\n            v = 12\n        elif v > 12:\n            v = v - 12\n        f = f.replace('%I', zf2(v))\n\n    return f\n\n"
	],
	"mappings": "AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2BA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AASA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AAWA;AAEA;AAAA;AAEA;AAWA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAWA;AACA;AAGA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AAAA;AAGA;AAEA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AASA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AAEA;AAEA;AAGA;AAMA;AAAA;AAGA;AACA;AAAA;AAGA;AAEA;AACA;AAAA;AAGA;AAQA;AACA;AAAA;AACA;AAAA;AAGA;AAQA;AACA;AAAA;AACA;AAAA;AAGA;AAQA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAIA;AA+BA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAGA;AACA;AAAA;AAGA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAGA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}